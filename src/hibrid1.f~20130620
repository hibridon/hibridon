*************************************************************************
*                                                                       *
*                         hibridon 1  library                           *
*                                                                       *
*************************************************************************
*                          routines included:                           *
*                                                                       *
*   2. airprp        airy zeroth-order propagator                       *
*   2a. gndloc       computes ground state wf and transform to local    *
*                    basis                                              *
*   3. airymp        returns the moduli and phases of the airy          *
*                    functions and their derivatives                    *
*   4. cbesj         centrifugal scattering function and its            *
*                    derivative.(first kind)                            *
*   5. cbesn         centrifugal scattering function and its            *
*                    derivative.(second kind)                           *
*   6. corr          determines approximate values for diagonal and     *
*                    off-diagonal correction terms in airy propagator   *
*   7. dtrans        computes  b * a * b-transpose                      *
*   8. difcrs (ampli/sphn/plm)  computes differential cross sections    *
*   9. difs (compar,compt2)         compares two s-matrices             *
*   Note:  Moved hypxsc to a separate file (hihypxsc.f)                 *
*      (5-jun-2013, q. ma)                                             *
*                                                                       *
*************************************************************************
* NB cstart aix-unix uses fortran rather than essl routines
*************************************************************************
      subroutine airprp (z, w, tmat, vecnow, vecnew,
     +   eigold, eignow, hp, y1, y2, cc, y4, gam1, gam2,
     +   xf, rend, drnow, en,
     +   tolai, rincr, eshift, nch, nmax, itwo, iprint, twoen, noprin)
*  airy zeroth-order propagator from r=xf to r=rend
*  for reference see m. alexander, "hybrid quantum scattering algorithms ...",
*                    j. chem. phys. 81, 4510 (1984)
*                and m. alexander and d. manolopoulos, "a stable linear
*                    reference potential algorithm for solution ..."
*                    j. chem. phys. 86, 2044 (1987)
***********************************************************************
****   this integrator is not released for general public use      ****
****   all use must be by specific prior arrangement with:         ****
****     millard alexander, department of chemistry,               ****
****     university of maryland, college park, md, 20742-2021      ****
****     tel: 1.301.405.1823; email: mha@umd.edu                   ****
****   no part of this program may be copied or used for other     ****
****   purposes without the author's permission.                   ****
***********************************************************************
*  author:  millard alexander
*  current revision date (the propagator): 30-dec-1995
*  revised on 30-mar-2012 by q. ma for stream I/O of wfu files
*  current revision: 8-oct-2012 by q. ma
* ----------------------------------------------------------------------------
*  definition of variables in call list:
*   z:               matrix of maximum dimension nmax*nmax
*                    on entry z contains the initial z-matrix at r=xf
*                    on return z contains the z-matrix at r=rend
*   w, tmat, vecnow
*    , vecnew:       scratch matrices of dimension at least nch*nch
*  eigold, eignew
*    , hp, y1, y2
*    , cc, y4, gam1,
*      gam2  :       scratch vectors of dimension at least nch
*  xf:               on entry: contains initial value of interparticle distanc
*                    on exit:  contains final value of interparticle distance
*                              this is equal to rend if normal termination
*                              otherwise an error message is printed
*  drnow:            on entry:  contains initial interval size
*                    on exit:  contains final interval size
*  en:               collision energy in atomic units
*  tolai:            parameter to determine step sizes
*                    if tolai .lt. 1, then estimated errors are used to
*                    determine next step sizes following the procedure outline
*                    in m.h. alexander, "hybrid quantum scattering algorithms
*                    if tolai .ge. 1, then step sizes are controlled by the
*                    algorithm:  drnext = tolai * drnow
*  rincr:            step size increase will occur only if rnext > rincr
*  variables in common block /cophot/
*     photof        true if photodissociation calculation
*                   false if scattering calculation
*     wavefn        true if G(a,b) transformation matrices are saved
*                   to be used later in computing the wavefunction
*  variables in common block /coqvec/
*     mxphot        maximum column dimension of q matrix
*     nphoto        actual collumn dimension of q matrix
*     q             accumulated gamma2 inhomogeneous propagator
*                   only calculated if photof = .true.
*                   this is stored as a column vector for each separate
*                   ground-state wavefunction
*  variable in common block /cowave/
*     irec          record number of last written G(a,b) matrix
*     ifil          local unit number for G(a,b) file
*  variables in common block /coered/
*    ered:      collision energy in atomic units (hartrees)
*    rmu:       collision reduced mass in atomic units (mass of electron = 1)
*  logical variables:
*     iprint:       if .true., then print out of step-by-step information
*     twoen:        if .true., then
*           itwo.eq.0, transformation matrices and relevant information
*             for propagation is written into file 10 for second energy
*           itwo.gt.0, transformation matrices and relevant information
*             for propagation is read from file 10 for second energy
*             calculation at energy=en+eshift
*     noprin:       if .true., then most printing is suppressed
* ----------------------------------------------------------------------------
      implicit double precision (a-h, o-z)
      integer i, icol, iend, ierr, ipt, itwo, izero, kstep, maxstp,
     :        nch, ncol, nmax, npt, nskip
      logical iprint, twoen, noprin, photof, wavefn, boundf, wrsmat
      common /cophot/ photof, wavefn, boundf, wrsmat
      common /cowave/ irec, ifil, nchwfu, ipos2, ipos3, nrlogd, iendwv,
     $     inflev
      common /coqvec/ mxphot, nphoto, q
      common /cosc10/ sc10(2)
      common /coered/ ered, rmu
      common /coipar/ ipar(9),jprint
      common /coselb/ ibasty
cstart unix-ibm
c;      character*1 forma, formb
cend
*  matrix dimensions (row dimension = nmax, matrices stored column by column)
      dimension z(80), w(80), tmat(80), vecnow(80), vecnew(80)
*  vectors dimensioned nch
      dimension eigold(80),eignow(80),hp(80),y1(80),y2(80),cc(80),
     :    y4(80),gam1(80), gam2(80)
*  vectors dimensioned nphoto*nch
      dimension q(80)
      data izero, ione, zero, one /0, 1, 0.d0, 1.d0/
*  powr is the power at which step sizes increase
*  only for tolai < 1
*  this used to be an input; now it is not
      data powr /3.d0/
c     The following variables are for size-determination of (machine
c     dependent) built-in types
      integer int_t
      double precision dble_t
      character char_t

* ----------------------------------------------------------------------------
      if (.not.twoen) itwo = -1
      if (itwo .gt. 0) go to 60
      if (photof) then
        nqmat=nphoto*nch

        write (6, 20)
        write (9, 20)
20      format (' GAMMA2 INITIALIZED AT BEGINNING OF AIRPRP')
        call dset(nqmat,zero,q,1)
      endif
      spcmx = zero
      spcmn = rend - xf
      rmin = xf
*  determine local wavevectors at rmin to use in estimating second derivatives
*  hp and y1 are used as scratch vectors here
      call wavevc (w, eigold, hp, y1, rmin, nch, nmax)
*  local wavevectors at rmin are returned in eigold
      drfir = drnow
      drmid = drnow * 0.5
      rlast = xf
      rold = xf
      rnow = rlast + drmid
      rnext = rlast + drnow
*  define local basis at rnow and carry out transformations
*  vecnew is used as scratch matrix and y1 is used as scratch vector here
      call potent (w, vecnow, vecnew, eignow, hp, y1,
     +             rnow, drnow, en, xlarge, nch, nmax)
*  vecnow is transformation from free basis into local basis
*  in first interval
*  e.g. p1=vecnow  ; see eq.(23) of
*  m.h. alexander, "hybrid quantum scattering algorithms ..."
*  store vecnow in tmat
      call matmov (vecnow, tmat, nch, nch, nmax, nmax)
*  determine approximate values for diagonal and off-diagonal
*  correction terms
      call corr (eignow, eigold, hp, drnow, drmid, xlarge, cdiag,
     :           coff, nch)
      maxstp = ( (rend-xf) / drnow ) * 5
      xf = rend
      if (iprint) then
        write (9, 40)
40      format(/' ** AIRY PROPAGATION (NO DERIVATIVES):')
        write (9, 50)
50      format('   STEP   RNOW', 5x, 5hdrnow, 5x, 5hcdiag, 6x, 4hcoff)
        if (jprint .ge. 2) write (9, 55)
55      format ('   ALSO ADIABATIC ENERGIES (HARTREE)')
      end if
60    iend = 0
      if (itwo .lt. 0) go to 70
*  write or read relevant information
      call outmat (tmat, eigold, hp, eshift, drnow, rnow,
     :             nch, nmax, itwo)
*  start airy propagation
* ----------------------------------------------------------------------------
 70   do 200  kstep = 1, maxstp
*  transform log-deriv matrix from local basis in last interval to
*  local basis in present interval.  see eq.(23) of
*  m.h. alexander, "hybrid quantum scattering algorithms ..."
*  w is used as scratch matrix here, and y1 is scratch array
*  if photodissociation calculation, transform gamma2 into local
*  interval
        if (photof) then
cstart unix mac .and. .not.unix-ibm
          call mxma(tmat,1,nmax,q,1,nphoto,w,1,nmax,nch,nch,nphoto)
cend
cstart  unix-ibm
c;          forma='N'
c;          call dgemul(tmat,nmax,forma,q,nmax,forma,
c;     :                w,nmax,nch,nch,nphoto)
cend
        call dcopy(nqmat,w,1,q,1)
        endif
*  determine ground state wavefunction and derivative and then
*  transform these into local basis (photodissociation)
*  y1 and y4 are used as scratch vectors here
      if (photof) call gndloc(vecnow,w,rnow,drnow,nch,nmax)
*  transform logderivative matrix into current interval
      call dtrans ( z, tmat, w, y1, xlarge, nch, nmax, izero)
*  tmat is no longer needed
*  solve for log-derivative matrix at right-hand side of
*  present interval.  this uses new algorithm of manalopoulos and alexander
*  namely
*               (n)    (n)      -1   (n)      (n)
*     z    = - y    [ y    + z ]    y     +  y
*      n+1      2      1      n      2        4
*  where y  , y  , and y   are the (diagonal) elements of log-derivative
*         1    2        4
*  propagator defined in alexander and manolopoulos
*  determine these diagonal matrices
*  eqs. (38)-(44) of m. alexander and d. manolopoulos, "a stable linear
*                    reference potential algorithm for solution ..."
        call spropn ( rnow, drnow, eigold, hp, y1, y4, y2,
     :                   gam1, gam2, nch)
*  set up matrix to be inverted
*  nskip is spacing between diagonal elements of matrix stored column by colum
        nskip = nmax + 1
        call daxpy (nch, one, y1, 1, z, nskip)
*  invert (y  +  z )
*           1     n
*  hp and cc are used as scratch arrays here
cstart .not. unix-darwin .and. .not. unix-x86
c;        call smxinv (z, nmax, nch, hp, cc, ierr)
cend
cstart unix-darwin unix-x86
        call syminv(z,nmax,nch,ierr)
cend
        if (ierr .ne. 0) then
          write (9, 80) kstep
          write (6, 80) kstep
80        format ('  *** INSTABILITY IN SMXINV IN AIRPRP, KSTEP=', i3,
     :          ' ABORT ***')
          call exit
        end if
*  z now contains Z(0,rlast,rnext) in DEM's notation
*  if photodissociation calculation,
        if (photof) then
*  add gamma1(rlast,rnext) to gamma2(0,rlast) to form zeta(0,rlast,nrext)
          call vadd(1,q,1,gam1,1,nqmat)
*  then premultiply by Z(0,rlast,rnext)
cstart unix mac .and. .not.unix-ibm
          call mxma(z,1,nmax,q,1,nphoto,tmat,1,nmax,nch,nch,nphoto)
cend
cstart  unix-ibm
c;          forma='N'
c;          call dgemul(z,nmax,forma,q,nmax,forma,
c;     :                tmat,nmax,nch,nch,nphoto)
cend
* if wavefunction desired, temporarily save local mu(a,b) propagator
* this is now in the first column of tmat
        if (wavefn) call dcopy(nch,tmat,1,sc10,1)
*  premultiply by y3 and add to existing q
*  cc is used as scratch array here
          ind=1
          jnd=1
          do 85  i = 1, nphoto
            call vmul(y2,1,tmat(jnd),1,cc,1,nch)
            call vadd(1,gam2(ind),1,cc,1,nch)
            call dcopy(nch,gam2(ind),1,q(ind),1)
            ind=ind+nch
            jnd=jnd+nmax
85        continue
* q now contains gamma2(0,rnext) in local basis
        endif

*                            -1
*  evaluate  - y  ( y  + z )    y
*               2    1    n      2
*  in the next loop evaluate the full, rather than lower triangle
*  changed for photodissociation calculation, old commands kept with
*  c in first column
      npt = 1
      do 90  i = 1, nch
        ncol = nch
c        ncol = nch - i + 1
        fact = y2(i)
        call dscal (ncol, fact, z(npt), 1)
        npt = npt + nmax
c        npt = npt + nskip
90    continue
*                            -1
*  z now contains  ( y  + z )    y  , this is G(n-1,n) in the local basis
*                     1    n      2
      if (wavefn) then
* save this matrix as well as transformation matrix
* into local interval and local propagators
c
         irec = irec + 1
         write (ifil, err=950) -rlast, drnow
c     Adiabatic energies
         write (ifil, err=950) (eigold(i), i=1, nch)
c     The following information will not be written if wrsmat set to F
         if (wrsmat) then
            icol = 1
            do ich = 1, nch
               write (ifil, err=950) (z(icol - 1 + i), i=1, nch)
               icol = icol + nmax
            end do
            icol = 1
            do ich = 1, nch
               write (ifil, err=950) (vecnow(icol - 1 + i), i=1, nch)
               icol = icol + nmax
            end do
c
            write (ifil, err=950) (y1(i), i=1, nch), (y2(i), i=1, nch),
     $           (y4(i), i=1, nch), (gam1(i), i=1, nch),
     $           (sc10(i), i=1, nch)
            lrairy = (2 * nchwfu ** 2 + 6 * nchwfu + 2)
     $           * sizeof(dble_t) + 8 * sizeof(char_t)
         else
            lrairy = (nchwfu + 2) * sizeof(dble_t) + 8 * sizeof(char_t)
         end if
c
         write (ifil, err=950) 'ENDWFUR', char(mod(irec, 256))
         iendwv = iendwv + lrairy
      end if
c
      do 110  i = 1, nch
        fact = - y2(i)
        call dscal (i, fact, z(i), nmax)
110   continue
*  add on  y
*           4
      npt = 1
      call daxpy (nch, one, y4, 1, z, nskip)
*  now fill in upper half of z matrix
      ipt = 2
      if (nch .gt. 1) then
        do  120  icol = 1, nch - 1
*       ncol is number of subdiagonal elements in column icol
*       ipt points to the first subdiagonal element in column icol
*       (ipt + nmax - 1) points to the first superdiagonal element in row icol
          ncol = nch - icol
          call dcopy (ncol, z(ipt), 1, z(ipt + nmax -1), nmax)
          ipt = ipt + nskip
120     continue
      end if
      if (itwo .gt. 0) go to 160
*  obligatory write of step information if deviations from linear
*  potential are unusually large
*  this is only done if tolai .lt. 1, in which case the largest correction
*  is used to estimate the next step
      if (tolai .lt. 1.d0) then
        cmax = max (cdiag, coff)
        if (cmax .gt. (5.d0* tolai)) then
          write (9,125)
          write (6,125)
125       format
     :    (' ** ESTIMATED CORRECTIONS LARGER THAN 5*TOLAI IN AIRPRP')
          if (kstep .eq. 1) then
            write (9, 130)
            write (6, 130)
130         format ('    THE INITIAL VALUE OF DRNOW (SPAC*FSTFAC) IS',
     :              ' PROBABLY TOO LARGE')
          else
            write (9, 140)
            write (6, 140)
140         format
     :      ('   CHECK FOR DISCONTINUITIES OR UNPHYSICAL OSCILLATIONS',
     :     /,'   IN YOUR POTENTIAL')
          end if
          if (.not. iprint) then
            write (9, 50)
            write (9,150) kstep, rnow, drnow, cdiag, coff
          end if
        end if
      end if
*     write out information about step just completed
      if (iprint) then
        write (9,150) kstep, rnow, drnow, cdiag, coff
150     format (i6, 4e10.3)
      end if
*     get set for next step
160   if (iend .eq. 1) go to 250
      if (itwo .gt. 0) go to 180
*  if tolai .lt. 1, predict next step size from largest correction
      if (tolai .lt. 1.) then
*  note that the following statement is slightly different from  eq. (30)
*  of m.h. alexander, "hybrid quantum scattering algorithms ...  and that
*  the step-size algorithm is only approximately  related to any real
*  estimate of the error coff and cdiag should be approximately tolai, so
*  from eq. (27):
*  drnow(at n+1) = (12 tolai/kbar(n+1)w(n+1)-tilda')**(1/3)
*  which is approximately = (12 tolai/kbar(n)w(n)-tilda')**(1/3)
*                         = ((12 coff/kbar w-tilda') (tolai/coff))**(1/3)
*                         = drnow(at n) (tolai/coff)**(1/3)
*  or from eq. (29):
*                   drnow = drnow (tolai/cdiag)**(1/3)
*  then, using the larger error and allowing pow to vary:
* (note 1/23/92 powr fixed at 3 in data statement)
*  step size increase occurs only if rnext > rincr
          if (rnext .gt. rincr)
     :            drnow = drnow * (tolai/cmax) ** (1.d0 / powr)
        else
*  if tolai .ge. 1, then
*  minimum step size is first interval width
          if (kstep .eq. 1) spcmn = drnow
*  and next step size is tolai * present step size
* only if rnext > powr
          if (rnext .gt. rincr) drnow = tolai * drnow
        end if
*  drnow is step size in next interval
      rlast = rnext
      rnext = rnext + drnow
      if (rnext .lt. rend) go to 170
      iend = 1
      rnext = rend
      drnow = rnext - rlast
170   rnew = rlast + 0.5d0 * drnow
      if (kstep .gt. 1 .and. iend .ne. 1) then
        if (tolai .lt. 1) then
          if (drnow .lt. spcmn) spcmn = drnow
        end if
        if (drnow .gt. spcmx) spcmx = drnow
      end if
      drmid = rnew - rnow
*  restore eigenvalues
      call dcopy (nch, eignow, 1, eigold, 1)
*  define local basis at rnew and carry out transformations
*  tmat is used as scratch matrix and y1 is used as scratch vector here
      call potent (w, vecnew, tmat, eignow, hp, y1,
     +             rnew, drnow, en, xlarge, nch, nmax)
*  determine matrix to transform log-deriv matrix into new interval
*  see eq. (22) of m.h. alexander, "hybrid quantum scattering algorithms ..."
*  on return from subroutine 'steppr':
*    the matrix pn [eq.(22)] is stored in
*    and vecnew has been transfered to vecnow; i.e. vecnow contains
*    the matrix tn [eq.(22)]
      call steppr (vecnow, vecnew, tmat, nmax, nch)
*  restore radius values
      rnow = rnew
*  determine approximate values for diagonal and off-diagonal
*  correction terms
      call corr (eignow, eigold, hp, drnow, drmid, xlarge, cdiag,
     :           coff, nch)
      if (itwo .lt. 0) go to 200
      if (iend .eq. 1) rnow = - rnow
*  write or read relevant information
180   call outmat (tmat, eigold, hp, eshift, drnow, rnow,
     :             nch, nmax, itwo)
      if (itwo .eq. 0) go to 200
*  negative rnow is cue for last step in second energy calculation
      if (rnow .gt. 0.d0) go to 200
      rnow = - rnow
      iend = 1
*     go back to start new step
200   continue
*  the following statement is reached only if the integration has
*  not reached the asymptotic region in maxstp steps
      write (9,210) maxstp, rnext
210   format (' *** AIRY PROPAGATION NOT FINISHED IN', i4,
     :        ' STEPS:  R-FIN SET TO', f8.4,' ***',/)
      xf = rnext
250   continue
      if (itwo .lt. 0) go to 260
      call outmat (vecnow, eigold, hp, eshift, drnow, xf, nch,
     :             nmax, itwo)
*  transform log-deriv matrix into free basis.  transformation matrix is
*  just vecnow-transpose; see eq.(24) of m.h. alexander, "hybrid quantum
*  scattering algorithms ..."
260   call transp (vecnow, nch, nmax)
* if photodissociation calculation, also transform gamma2 to free basis
      if (photof) then
cstart unix mac .and. .not.unix-ibm
          call mxma(vecnow,1,nmax,q,1,nphoto,w,1,nmax,nch,nch,nphoto)
cend
cstart  unix-ibm
c;          forma='N'
c;          call dgemul(vecnow,nmax,forma,q,nmax,forma,
c;     :                w,nmax,nch,nch,nphoto)
cend
        ind=1
        jnd=1
        do 265 i=1,nphoto
          call dcopy(nch,w(jnd),1,q(ind),1)
          ind=ind+nch
          jnd=jnd+nmax
265     continue
      endif
      call dtrans (z, vecnow, w, hp, xlarge, nch, nmax, izero)
* if 2s-2p collisions, restore asymptotic case (e) energies
      if (ibasty .eq. 10) call energ22
      if (noprin) go to 320
      if (itwo .lt. 0) write (9,280)
      if (itwo .eq. 0) write (9,290)
      if (itwo .gt. 0) write (9,300)
280   format (' ** AIRY PROPAGATION - FIRST ENERGY;',
     :        ' TRANSFORMATION MATRICES NOT WRITTEN')
290   format (' ** AIRY PROPAGATION - FIRST ENERGY;',
     :        ' TRANSFORMATION MATRICES WRITTEN')
300   format (' ** AIRY PROPAGATION - SECOND ENERGY;',
     :        ' TRANSFORMATION MATRICES READ')
      write (9,305) rmin, rend, tolai, kstep
      write (9,310) spcmn, spcmx, rincr
305   format ('         RBEGIN =', f7.3, '  REND =', f7.3,
     :        '     TOLAI =', 1pe8.1, '  NINTERVAL =', i3)
310   format ('         DR-MIN =', f7.3, '  DR-MAX =', f8.3,
     :        '  R-INCR =', f7.3)
      write (6, 315) rmin, rend, rincr, spcmn, spcmx, kstep
315   format (' ** AIRY:  RSTART =' ,f7.3,'  REND =',f7.3,
     :        '   RINCR =',f7.3,
     :        '   DRMIN =',f7.3, '   DRMAX =',f7.3,'   NSTEP =', i4)
320   continue
      return
c
 950  write (0, *) ' *** ERROR WRITING WFU FILE (AIRY). ABORT.'
      call exit()
      end
* ----------------------------------------------------------------------
      subroutine gndloc (vecnow, scr, rnow, drnow, nch, nmax)
* ----------------------------------------------------------------------
*  this subroutine first determines the ground state wavefunction at
*    rnow +/- 0.5 drnow/sqrt(3), to estimate the function and its
*    derivative to use in airy propagation.  the chosen points are the
*    nodes of a two-point gauss-legendre quadrature
*  the function and its derivative are then transformed into the local basis
*  author:  millard alexander
*  current revision date: 20-sep-1994
* ---------------------------------------------------------------------
*  variables in call list:
*    vecnow:   contains Tn matrix (transformation into local basis)
*    scr:      scratch matrix
*    rnow:     midpoint of the current interval
*    drnow:    width of the current interval
*    nch:      number of channels
*    nmax:     maximum row dimension of matrices and maximum dimension of
*              vectors
* ----------------------------------------------------------------------
      implicit double precision (a-h,o-z)
*  square matrices (of row dimension nmax)
      dimension vecnow(80), scr(80)
      dimension q(80)
      common /coqvec2/ q
      common /cotq1/ tmat(80)
      data one, onemn, half, sq3 /1.d0, -1.d0, 0.5d0, 1.732050807d0/
      ra = rnow - half * drnow / sq3
      rb = rnow + half * drnow / sq3
      fact = sq3 / drnow
      nphoto=1
      mxphot=nch*nphoto
*  save vecnow in matrix tmat
      call matmov(vecnow,tmat,nch,nch,nmax,nch)
      call ground(scr, ra, nch, nphoto, mxphot)
      call ground(q, rb, nch, nphoto, mxphot)
      call dcopy(nch,q,1,q(nch+1),1)
      call daxpy(nch,one, scr,1,q,1)
      call daxpy(nch,onemn, scr,1,q(nch+1),1)
      call dscal(nch,half,q,1)
      call dscal(nch,fact,q(nch+1),1)
*  activate the next statement to kill derivatives of ground state
*  function
*      call dset(nch,0.d0, q(nch+1),1)
*  average ground state wavefunction now stored in first column of q
*  derivative stored in second column of q
*  now transform these into local basis
      call mxma(vecnow,1,nmax,q,1,nch,scr,1,nch,nch,nch,2)
      call dcopy(2*nch,scr,1,q,1)
      return
      end
* -----------------------------------------------------------------------
      subroutine cbesn(l,p,x,cn,cnp)
c
c     centrifugal scattering function and its derivative.(second kind)
c     (defined j. comp. phys. vol 13,page 447)
c     this routine returns cn = ricatti-bessel function yl(p x) / sqrt(p)
c                          chp = d cn / dx = sqrt(p) d yl(p,x) / d(px)
c     or, in smp notation, if
c     u = p x
c     cn : yl_hat[u] / sqrt(p)
c     cnp : d[cn,x] : sqrt(p) d[yl_hat[u],u]
c     here we have used the definitions in abramowitz and stegun
c     this subroutine is unchanged from the original version written
c     by b.r. johnson
c     obtained from nrcc 1979
c
c     current revision date: 24-sept-87
c
      implicit double precision (a-h,o-z)
      ps = sqrt(p)
      r = p*x
      if(l-1) 1,2,3
1     cn = -cos(r)/ps
      cnp = ps*sin(r)
      return
2     cn = -(cos(r)/r+sin(r))/ps
      cnp = -ps*cos(r)-cn/x
      return
3     fnm1 = -cos(r)/r
      fn = (fnm1 - sin(r))/r
      tnp1dr = 1.0d0/r
      tr = 2.0d0/r
      do  100   i = 2,l
      tnp1dr = tnp1dr + tr
      fnp1 = tnp1dr*fn-fnm1
      fnm1 = fn
100   fn = fnp1
      cn = fn*ps*x
      cnp = ps*(r*fnm1-dble(l)*fn)
      return
      end
* -----------------------------------------------------------------------
      subroutine cbesj(l,p,x,cj,cjp)
c
c     centrifugal scattering function and its derivative.(first kind)
c     (defined j. comp. phys. vol 13,page 447)
c     this routine returns cj = ricatti-bessel function jl(p x) / sqrt(p)
c                          cjp = d cj / dx = sqrt(p) d jl(p,x) / d(px)
c     or, in smp notation, if
c     u = p x
c     cj : jl_hat[u] / sqrt(p)
c     cjp : d[cj,x] : sqrt(p) d[jl_hat[u],u]
c     here we have used the definitions in abramowitz and stegun
c     this subroutine is unchanged from the original version written
c     by b.r. johnson
c     obtained from nrcc 1979
c
c     current revision date: 24-sept-87
c
      implicit double precision (a-h,o-z)
      data zero,one,two /0.d0,1.d0,2.d0/
      ps = sqrt(p)
      r = p*x
      if(l.ne.0)  go to 100
      cj = sin(r)/ps
      cjp = ps*cos(r)
      return
100   if(r.ge.dble(l))  go to 500
c
c     millers method (recur down)
c
      lim = l
      test = 1.d8
      tl1 = 2*lim + 1
      tl1dr = tl1/r
      tdr = two/r
      fn = one
      fnm1 = zero
      do  401   i = 1,1000
      fnp1 = tl1dr*fn-fnm1
      tl1dr = tl1dr + tdr
      fnm1 = fn
      fn = fnp1
      if(abs(fn).lt.test)  go to 401
      max = i
      go to 403
401   continue
      write(9,404)
404   format(' *** no convergence in downward recurrence for cbesj;',
     :       '  abort ***')
      stop
403   n = lim + max
      maxx = n - l
      tnp = 2*n + 3
      coef = tnp/r
      fnp1 = zero
      fn = one
      do  405   i = 1,maxx
      coef = coef - tdr
      fnm1 = coef*fn - fnp1
      fnp1 = fn
405   fn = fnm1
      fnp1 = fnp1/fn
      fn = one
      ratio = fnp1
      do  410   i = 1,l
      coef = coef - tdr
      fnm1 = coef*fn - fnp1
      fnp1 = fn
410   fn = fnm1
      cj = ps*x/((fn-r*fnp1)*cos(r) + r*fn*sin(r))
      cjp = cj*(dble(l+1)/x - p*ratio)
      return
c
c     recur up
c
500   if(l.gt.1)  go to 3
      cj = (sin(r)/r-cos(r))/ps
      cjp = ps*sin(r)-cj/x
      return
3     fnm1 = sin(r)/r
      fn = (fnm1-cos(r))/r
      tnp1dr = one/r
      tr = two/r
      do  600   i = 2,l
      tnp1dr = tnp1dr + tr
      fnp1 = tnp1dr*fn-fnm1
      fnm1 = fn
600   fn = fnp1
      cj = fn*ps*x
      cjp = ps*(r*fnm1-dble(l)*fn)
      return
      end
* -----------------------------------------------------------------------
      subroutine corr (eignow, eigold, hp, drnow, drmid, xlarge,
     :                 cdiag, coff, nch)
*  subroutine to determine approximate values for diagonal and off-diagonal
*  correction terms in airy propagator
*  also copies new eigenvalues from array eignow into array eigold
*  author:  millard alexander
*  current revision date: 27-sept-87
*
*  -------------------------------------------------------------------------
*  variables in call list:
*    eignow:    on entry: vector containing eigenvalues of wavevector matrix
*               in current interval
*    eigold:    on entry: vector containing eigenvalues of wavevector matrix
*               in previous interval
*               on return: vector containing eigenvalues of wavevector matrix
*               in current interval
*    hp:        vector containing diagonal elements of derivative of
*               transformed hamiltonian matrix in current interval
*               this is the same as the negative of the diagonal elements of
*               the wn-tilde-prime matrix
*    drnow:     width of current interval
*    drmid:     distance between mid-point of current interval and mid_point o
*               previous interval
*    xlarge:    largest off-diagonal elemtent in transformed wavevector matrix
*               in current interval
*    cdiag:     on return:  contains estimate of error due to neglected
*               diagonal elements of wn-tilde-double prime matrix
*               see eq.(29) of m.h. alexander, "hybrid quantum scattering
*               algorithms"
*    coff:     on return:  contains estimate of error due to neglected
*               off-diagonal elements of wn-tilde-prime matrix
*               see eq.(26) of m.h. alexander, "hybrid quantum scattering
*               algorithms"
*    nch:       number of channels
*  ----------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      data zero,one,two /0.d0, 1.d0, 2.d0/
*      real  cay, cdiag, coff, drmid, drnow, factor, w2p, xlarge
*      real eignow, eigold, hp
*      real sqrt
      integer i, nch
*  arrays, must be dimensioned at least nch
      dimension eignow(1), eigold(1), hp(1)
      factor = two / (drmid**2)
      cay = zero
      cdiag =zero
      do 30  i = 1 , nch
*  ----------------------------------------------------------------------
*  estimate second derivative of wavevector by power series expansion
*                                                        2   2    2
*       w(r ) = w(r ) + (r  - r ) (dw/dr) + 0.5 (r  - r )  (d w/dr )
*          2       1      2    1         r        2    1            r
*                                         1                          1
*  which can be rearranged to give [since drmid = r - r  and hp = - (dw/dr) ]
*                                                  1   2
*         2    2                                                  2
*       (d w/dr ) = - 2 [ w(r ) - w(r ) + drmid * hp(r ) ] / drmid
*                r           1       2
*                 1
*  ----------------------------------------------------------------------
        w2p =  - factor * (eignow(i) - eigold(i) + drmid * hp(i))
        cdiag = cdiag + abs(w2p)
        cay = cay + sqrt (abs(eignow(i)))
30    continue
      cay = cay / dble(nch)
      cdiag = cdiag / dble(nch)
*  cay now contains average wavevector magnitude
*  cdiag now contains average magnitude of the second derivative of the
*    wavevector array
*  now calculate estimate of error
      cdiag = (drnow**3) * cdiag / 12.d0
      coff = cay * xlarge * (drnow**3) / 12.d0
*  now copy new eigenvalue array into eigold
      call dcopy (nch, eignow, 1, eigold, 1)
      return
      end
* -----------------------------------------------------------------------
      subroutine dtrans (a, b, c, diag, xlarge, n, nmax, ifind)
* -----------------------------------------------------------------------
*  to compute b * a * b-transpose
*  author:  millard alexander
*  current revision date:  28-dec-2003
* -----------------------------------------------------------------------
*  variables in call list:
*    a:       on return contains b * a * b-transpose
*    b:       on entry contains multiplicand matrix, this matrix is destroyed
*    c:       scratch matrix
*    diag:    if ifind .gt. 0, then on return the vector diag contains the
*             diagonal elements of b * a * b-transpose
*    xlarge:  if ifind .gt. 0, then on return the maximum (in magnitude)
*             off-diagonal element of b * a * b-transpose is returned as xlarg
*    n:       order of matrices and length of vector diag
*    nmax:    maximum row dimension of a, b, c in calling program
*    ifind:   integer variable, if ifind .gt. 0, then diag and xlarge are
*             computed as described above
*  all matrices are stored in packed column form
*  subroutines called:
*  rgmmul:      generalized matrix multiply ( a * b = c or a * b-transpose = c
*  dcopy:       linpack blas
*  maxmgv:      find maximum (absolute value) element in a vector
c -----------------------------------------------------------------------
      implicit double precision (a-h,o-z)
cstart unix-ibm
c;      character*1 forma, formb
cend
      integer ic, icol, ifind, ipt, n, ncol, nmax, isw
      dimension a(1), b(1), c(1), diag(1)
      isw = 0
cstart none
c;      call rgmmul (isw, n, n, n, b, 1, nmax, a, 1, nmax, c, 1, nmax)
c;      call rgmmul (isw, n, n, n, c, 1, nmax, b, nmax, 1, a, 1, nmax)
cend
ccstart unix mac .and. .not.unix-ibm
cstart none
c;       call mxma (b,1,nmax,a,1,nmax,c,1,nmax,n,n,n)
c;       call mxma (c,1,nmax,b,nmax,1,a,1,nmax,n,n,n)
cend
cstart unix-ibm
c;       forma='N'
c;       formb='T'
c;       call dgemul (b,nmax,forma,a,nmax,forma,c,nmax,n,n,n)
c;       call dgemul (c,nmax,forma,b,nmax,formb,a,nmax,n,n,n)
cend
cstart unix .and. .not.unix-ibm
       call dgemm('n','n',n,n,n,1.d0,b,nmax,a,nmax,0d0,c,nmax)
       call dgemm('n','t',n,n,n,1.d0,c,nmax,b,nmax,0d0,a,nmax)
cend

*  a now contains desired product
      if (ifind .le. 0) return
*  store diagonal elements in vector diag
*  nmax + 1 is the skip distrance for diagonal elements of the a-matrix
      call dcopy (n, a(1), nmax + 1, diag(1), 1)
*  now look for maximum (in absolute value) off-diagonal element
*  since matrix is symmetrical, only the lower triangle is searched
      xlarge = 0.d0
      ipt = 2
      do 15  icol = 1, n - 1
*  ipt points to first sub-diagonal element in column icol
*  ncol is the number of sub-diagonal elements in column icol
        ncol = n - icol
        call maxmgv (a(ipt), 1, zabs, ic, ncol)
        if (zabs .gt. xlarge) xlarge = zabs
        ipt = ipt + nmax + 1
15    continue
      return
      end
*  -------------------------------------------------------------
      subroutine difcrs(fname1,a,ihomo,flaghf)
*  -------------------------------------------------------------
*  calculates differential cross sections
*  author h.-j. werner
*  addition for negative nnout 2-8-95 by moonbong yang
*  revised to include 8pole alignment:  7-apr-2003
*  revised to include A22+ differential alignment moment:
*    4-sep-2010 by mha
*  revised to allow differential cross sections for molecule-
*    molecule collisions (specifically ibasty=9):
*    1-feb-2012 by p.dagdigian
*
*  current revision;  1-feb-2012 by p. dagdigian
*  -------------------------------------------------------------
      implicit double precision (a-h,o-z)
      character*(*) fname1
      character*20 cdate1
      character*20  cdate
      character*10  elaps, cpu
      character*40 xnam1,xnam2,xnam3
      character*1 m1string,m2string
      character*8 amplstring

      complex*16 q, qm, stampl, stamplm, fm1m2
      logical existf,csflg1,flghf1,flgsu1,ihomo,flaghf,twomol,
     1        nucros,iprint,mflag,stflag,is_j12
      parameter (maxang=901)
      include "common/parpot"
      common /coselb/ ibasty
      common /coz/ sreal1(1)
      common /cow/ simag1(1)
      common /cojq/ jq(1)
      common /colq/ lq(1)
      common /coinq/ inq(1)
      common /coj12/ j12(1)
      common /cojhld/ jlev(1)
      common /coisc1/ inlev(1)
      common /coisc2/ jout1(1)
      common /cosc1/ elev(1)
      common /cosc2/ jpack1(1)
      common /cosc3/ lpack1(1)
      common /cosc4/ ipack1(1)
      common /coj12p/ j12pk(1)
      common /codim/ mairy,mmax
      common /coamat/ q(1)
      common /cobmat/ qm(1)
      common /cozmat/ xintmdep(1)
      common /cov2/ nv2max, ndummy, y(1)
      common /coconv/ econv, xmconv, ang2c
      common /codifc/ s(1)
      dimension sm(maxang),sm6(maxang)
* to store a22p amplitudes
      dimension fm1m2(100,1000),a22(1000),a22fak(1000)
* to store rho and rho2 density matrices
      dimension rho(100,1000),rho2(100,1000)
      dimension a(15)
      data pi /3.1415927d0/
c
      maxq=mmax*mmax/2
      maxy=nv2max
c
c.....input parameters
c
      j1=a(1)
      in1=a(2)
      j2=a(3)
      in2=a(4)
      ang1=a(5)
      ang2=a(6)
      dang=a(7)
      ienerg=a(8)+0.1d0
      jtot1=0
      jtot2=a(9)
      iprint = .false.
      if (a(10) .ne. 0.d0) iprint = .true.
      mflag=.false.
* if mflag = .true., calculate mdependent cross sections in collision frame
      if (a(11).ne.0) mflag=.true.
      stflag=.false.
* if stflag = .true., calculate steric effect cross sections
      if (a(12).ne.0) then
         stflag=.true.
         alph1=a(13)
         alphm1=a(14)
         msteric=a(15)
         in1=iabs(in1)
      endif
      if (stflag) then
         if (.not.flaghf) then
             write (6,5)
5            format
     :   (' *** STFLAG = .TRUE. NOT ALLOWED FOR FLAGHF = .FALSE.')
             return
         else if (ibasty.ne.3) then
             write (6,7) ibasty
7            format
     :   (' *** STFLAG = .TRUE. NOT ALLOWED FOR IBASTY =',i3)
             return
         endif
      endif
      if (flaghf) then
         xj2=j2+0.5d0
      else
         xj2=j2
      endif
*
*  check for molecule-molecule collision (ibasty=9)
      if (ibasty .eq. 9 .or. ibasty .eq. 100) then
        is_j12 = .true.
      else
        is_j12 = .false.
      end if
*
      ang0=ang1
      if(ang2.eq.0) ang2=ang1+60.0d0
      if(dang.eq.0) dang=1.0d0
      if(ienerg.le.0) ienerg=1
c
c.....open s-matrix file
c
      call gennam(xnam1,fname1,ienerg,'smt',lenx)
      inquire (file=xnam1(1:lenx), exist=existf)
      if (.not. existf) then
        write (6, 10) xnam1(1:lenx)
10      format(/' FILE ',(a),' NOT FOUND')
        return
      end if
* initialize timer
      call mtime(cpu0,ela0)

      call openf(1,xnam1(1:lenx),'tu',0)
c
c.....open output file for differential cross sections
c
      ifil=1
20    call gennam(xnam2,fname1,ifil,'dcs',lenx)
      call openf(2,xnam2(1:lenx),'sf',0)
c.....open output file for final-m dependence of (m,m) and (m,m+2) density matrix
      if (mflag) then
         call gennam(xnam3,fname1,ifil,'rho',lenx)
         call openf(3,xnam3(1:lenx),'sf',0)
      endif
* write a header (mha 10/22/08, don't write this for easier import into matlab)
*      call version(2)
      call dater(cdate)
      write (2,23) cdate
      if (mflag) write (3,23) cdate
      write (6,22) cdate
22    format (/,'**  DIFFERENTIAL CROSS SECTION (ANG^2/SR)',
     :    /,'    TODAYS DATE:  ',(a))
23    format (/,'% **  DIFFERENTIAL CROSS SECTION (ANG^2/SR)',
     :    /,'%   TODAYS DATE:  ',(a))
c
c.....read header of s-matrix file
c
      call rdhead(1,cdate1,ered1,rmu1,csflg1,flghf1,
     1   flgsu1,
     1   twomol,nucros,jfirst,jfinal,jtotd,numin,numax,nud,
     1   nlevel,nlevop,nnout,jlev,inlev,elev,jout1)
      if(csflg1) then
        write(6,30)
30      format(/' DIFFERENTIAL CROSS SECTIONS NOT IMPLEMENTED FOR',
     1    ' COUPLED STATES APPROXIMATION'/)
        goto 500
      end if
c
c.....print job information
c
      write(2,41) xnam1,cdate1,label,potnam,econv*ered1,xmconv*rmu1
      if (mflag)
     :     write(3,41) xnam1,cdate1,label,potnam,econv*ered1,xmconv*rmu1
      write(6,40) xnam1,cdate1,label,potnam,econv*ered1,xmconv*rmu1
40    format('    S-MATRICES READ FROM FILE ',(a),/,
     : '      WRITTEN:   ',(a),/,
     : '      LABEL:     ',(a)/,
     : '      POT NAME:  ',(a)/,
     : '    E-TOT:   ',f10.3,';  REDUCED MASS:  ',1pg11.4)
41    format('%    S-MATRICES READ FROM FILE ',(a),/,
     : '%     WRITTEN:   ',(a),/,
     : '%     LABEL:     ',(a)/,
     : '%     POT NAME:  ',(a)/,
     : '%    E-TOT:   ',f10.3,';  REDUCED MASS:  ',1pg11.4)
      if(jtot2.eq.0) jtot2=jfinal
      jtot2=min0(jfinal,jtot2)
      if(jtotd.ne.1) then
        write(6,50) jtotd
50      format(' *** JTOTD =',i2,'.NE.1')
        goto 500
      end if
c
c.....check whether initial level exists
c
      do 60 j=1,nlevel
60    if(jlev(j).eq.j1.and.inlev(j).eq.in1) goto 90

      write(6,70) 'j1=',j1,'in1=',in1
70    format(/1x,(a),i2,2x,(a),i2,' NOT FOUND IN LEVEL LIST'//
     1           '   N  J  INDEX   EINT(CM-1)')
      write(6,80) (j,jlev(j),inlev(j),elev(j)*econv,j=1,nlevel)
80    format(1x,2i3,i5,f12.3)
c     check if other symmetry doublet exists for steric effect
82    if (stflag) then
         do 85 j=1,nlevel
85       if(jlev(j).eq.j1.and.inlev(j).eq.-in1) goto 90
         write(6,70) 'j1=',j1,'in1=',-in1
         write(6,80) (j,jlev(j),inlev(j),elev(j)*econv,j=1,nlevel)
      endif
      goto 500
c
c.....ca is wavevector for initial state, ecol is collision energy
c
* initialize for integral cross sections
90    xint=0d0
      xintm=0d0
      ecol= ered1-elev(j)
      ca=sqrt(2d0*rmu1*ecol)
c
      do 100 j=1,iabs(nnout)
100   if(j1.eq.jout1(j))  goto 120
      write(6,110) 'j1=',j1,(jout1(j),j=1,iabs(nnout))
110   format(/1x,(a),i2,' NOT FOUND IN JOUT LIST'/
     1        1x,'JOUT: ',20i3)
      goto 500
c
c.....ckeck whether second level exists
c
c added for negative nnout by moonbong yang 2-8-95

120   continue
*     write(6,*) 'nnout=',nnout
      if(nnout.le.0) goto 160

      do 130 j=1,nlevel
130   if(jlev(j).eq.j2.and.inlev(j).eq.in2) goto 140
      write(6,70) 'j2=',j2,'in2=',in2
      write(6,80) (j,jlev(j),inlev(j),elev(j)*econv,j=1,nlevel)
      goto 500
140   do 150 j=1,iabs(nnout)
150   if(j2.eq.jout1(j)) goto 160
      write(6,110) 'j2=',j2,(jout1(j),j=1,iabs(nnout))
      goto 500
c
c.....print header
c
160   write(2,171) j1,in1,j2,in2,jtot1,jtot2,ca,1.8897*ca,
     :             econv*ecol,econv*ecol/8.065465
      if (mflag) write(3,171) j1,in1,j2,in2,jtot1,jtot2,ca,1.8897*ca,
     :             econv*ecol,econv*ecol/8.065465
      write(6,170) j1,in1,j2,in2,jtot1,jtot2,ca,1.8897*ca,
     :             econv*ecol,econv*ecol/8.065465
170   format('    TRANSITION:  J1=',i4,' IN1=',i4,
     1        '  ->  J2=',i4,' IN2=',i4/
     1        '    SUMMING PARTIAL WAVES FROM JTOT = ',i1,
     :        ' TO',i4/
     1        '    WAVE VECTOR IN INITIAL CHANNEL:  ',f10.4,' Bohr^(-1)',
     :        '; ',f10.4,' Angstroms^(-1)',/
     :        '    COLLISION ENERGY: ',f10.4,' cm-1; ',f10.4,' meV')
171   format('%   TRANSITION:  J1=',i4,' IN1=',i4,
     1        '  ->  J2=',i4,' IN2=',i4/
     1        '%   SUMMING PARTIAL WAVES FROM JTOT = ',i1,
     :        ' TO',i4/
     1        '%   WAVE VECTOR IN INITIAL CHANNEL:  ',f10.4,' Bohr^(-1)',
     :        '; ',f10.4,' Angstroms^(-1)',/
     :        '%   COLLISION ENERGY: ',f10.4,' cm-1; ',f10.4,' meV')
      if (stflag) then
         write (6,173) msteric+0.5, alph1,alphm1
         write (2,172) msteric+0.5, alph1,alphm1
      endif
172   format('%    STERIC (ORIENTED) CROSS SECTIONS: M = ',f4.1,/,
     :        '        ALPH(1) =',f7.4,
     :        ', ALPH(-1)=',f7.4)
173   format('    STERIC (ORIENTED) CROSS SECTIONS: M = ',f4.1,/,
     :        '        ALPH(1) =',f7.4,
     :        ', ALPH(-1)=',f7.4)

      if (.not.iprint) write (6, 175) xnam2(1:lenx)
175   format('    DIFFERENTIAL CROSS SECTIONS SAVED IN FILE: ',(a))
      if (.not.iprint.and.mflag) write (6, 176) xnam3(1:lenx)
176   format('    ROTATIONAL DENSITY MATRIX ELEMENTS SAVED IN FILE: ',
     :       (a))
c
c.....determine number of angles per batch
c
         l2max=jtot2+j2+1
         mlmax=j1+j2+1
         ideg1=2*j1+1
         ideg2=2*j2+1
         j1p=j1
         j2p=j2
         if(flaghf) then
c.....here for half-integer spin
           l2max=l2max+1
           mlmax=mlmax+1
           ideg1=2*j1+2
           ideg2=2*j2+2
           j1p=j1+1
           j2p=j2+1
         end if
         ideg=ideg1*ideg2
         nangle=(ang2-ang1)/dang+1.4d0
         nangle=min0(maxang,nangle,maxq/(ideg1*ideg2),
     :                             maxy/(l2max*mlmax))
         nanghld=nangle
         if(nangle.eq.0) then
           write(6,180) maxq,maxy
180        format(' *** NOT ENOUGH CORE IN DIFCRS. MAXQ=',i6,
     :            ' MAXY=',i6)
           return
         end if
c
c
c.....zero out m-dependent integral cross sections
      indm=0
      do 195 mj1=-j1p,j1
      do 195 mj2=-j2p,j2
         indm=indm+1
         xintmdep(indm)=0d0
195   continue
c.....zero out amplitudes
c
200     ii=0
        nang=(ang2-ang1)/dang+1.4d0
        nangle=min0(nanghld,nang)
        do 215 mj1=-j1p,j1
        do 215 mj2=-j2p,j2
        do 210 i=1,nangle
        ii=ii+1
        a22(i)=0d0
* fm1m2 is array to accumulate f(j1m1->j2m2)
        fm1m2(mj2+j2p+1,i)=(0d0,0d0)
* rho is array to accumulate |f(j1m1->j2m2)|^2 summed over m1
* rho2 is array to accumulate Ref(j1m1->j2m2)|^2 summed over m1
        rho(mj2+j2p+1,i)=0d0
        rho2(mj2+j2p+1,i)=0d0
        q(ii)=0d0
210     qm(ii)=0d0
215     continue
c
c.....precalculate all required spherical harmonics
c
        ii=0
        do 230 ml=0,mlmax-1
        angle=ang1
        do 220 i=1,nangle
        call sphn(ml,l2max-1,angle,y(ii+i),nangle)
220     angle=angle+dang
230     ii=ii+l2max*nangle
        jtlast=-1
        jplast=0
c
c.....read next s-matrix
c
250   call sread (0,sreal1, simag1, jtot, jlpar, nu1,
     :                  jq, lq, inq, ipack1, jpack1, lpack1,
     :                  1, mmax, nopen1, lengt1, ierr)
      if(ierr.eq.-1) then
         write(6,260) xnam1,jtlast,jplast
260      format(' END OF FILE DETECTED READING FILE ',(a),
     :     ' LAST JTOT,JLPAR PROCESSED:',2i5)
         goto 310
      end if
      if(ierr.lt.-1) then
        write(6,270) xnam1,jtlast,jplast
270     format(' ERROR READING FILE ',(a),
     :     ' LAST JTOT,JLPAR PROCESSED:',2i5)
        goto 310
      end if
c
c.....this assumes that jlpar=1 is stored first
c
      if(jtot.gt.jtot2) goto 300
c
c.....copy row labels into column labels if s-matrices are stored
c.....triangular
c
      if(jlpar.eq.jplast.and.jtot.ne.jtlast+1) write(6,275) jtot,jtlast
275   format(' *** WARNING: JTOT.NE.JTLAST+1:',2i4)
      jtlast=jtot
      jplast=jlpar
      if(nnout.gt.0) then
         do 290 i=1,lengt1
         inq(i)=ipack1(i)
         jq(i)=jpack1(i)
290      lq(i)=lpack1(i)
         nopen1=lengt1
      end if
c
c.....calculate contributions to amplitudes for present jtot
c
      call ampli(j1,in1,j2,in2,jtot,sreal1,simag1,mmax,jpack1,lpack1,
     :  ipack1,lengt1,jq,lq,inq,nopen1,y,q,l2max,nangle,ihomo,flaghf,
     :  is_j12)
c.... calculate contributions for negative initial index
      if (stflag)
     :   call ampli(j1,-in1,j2,in2,jtot,sreal1,simag1,mmax,
     :     jpack1,lpack1,ipack1,lengt1,jq,lq,inq,nopen1,y,qm,
     :     l2max,nangle,ihomo,flaghf,is_j12)
c
c.....loop back to next jtot/jlpar
c
300   if(jtot.lt.jtot2.or.jlpar.eq.1) goto 250
c
c.....print differential cross sections for this batch of angles
c
310   angle=ang1
      do 330 i=1,nangle
      sm(i)=0d0
      sm6(i)=0d0
330   s(i)=0d0
      ii=0
      fak=ang2c/(ideg1*ca**2)
      faksq=sqrt(fak)
      indm=0
*
*  atom-molecule case
      if (.not. is_j12) then
      do 343 mj1=-j1p,j1
      do 340 mj2=-j2p,j2
         indm=indm+1
         if (flaghf) then
            xm=mj1+0.5d0
            xmj2=mj2+0.5d0
         else
            xm=mj1
            xmj2=mj2
         endif

* from C. H. Greene and R. N. Zare, J. Chem. Phys. 78, 6741 (1983)

* quadrupole alignment
*  A_0^(2)= <3m^2-j*(j+1)>/(j*(j+1))
* octupole alignment
*  A_0^(4)= <3(j*(j+1))^2-6(j*(j+1))-30m^2*j(j+1)+25m^2+35m^4>/8(j(j+1))^2
* A22+ moment
*\begin{eqnarray}
*A^{(2)+}_{2}(J)&=&(-1)^J \left [ \frac{2(2J-1)(2J+1)(2J+3)}{ J(J+1)}\right ]^{1/2}\nonumber \\
*&& \times \sum_{M=-J}^{J-2} (-1)^{-M}
*\left( {\begin{array}{*{20}c}
*   J & 2 & J  \\
*   { - M-2} & {  -2} & {M+2}  \\
*\end{array}} \right) {\CMcal{R}}\left({\rho_{M+2,M}}\right )
*\end{eqnarray}

* and
*\begin{equation}
*\rho_{M'M}= {{\sum\limits_{M''}^{} {f_{J''M'' \to JM'}^* } f_{J''M'' \to JM}} \mathord{\left/
* {\vphantom {{\sum\limits_{M''}^{} {f_{J''M'' \to JM'}^* } f_{J''M'' \to JM}} {\sum\limits_{M'',M'}^{} {\left|
*{f_{J''M'' \to JM'}} \right|^2 } }}} \right.
* \kern-\nulldelimiterspace} {\sum\limits_{M'',M'}^{} {\left| {f_{J''M'' \to JM'}} \right|^2 } }}
*\end{equation}

         fjjp1=xj2*(xj2+1)
         fjjp12=fjjp1*fjjp1
         xm2=xmj2*xmj2
         algfak=(3d0*xm2/fjjp1-1d0)
         octupfak=
     :      (3*fjjp12-6*fjjp1-30*fjjp1*xm2+25*xm2+35*xm2*xm2)/
     :      (8d0*fjjp12)
         xj2=j2
         if (flaghf) then
            xj2=xj2+0.5d0
         endif
         a2term=
     :       sqrt(2d0*(2*xj2-1)*(2*xj2+1)*(2*xj2+3)/(xj2*(xj2+1)))
         threej=xf3j(xj2,2d0,xj2,-xmj2,-2d0,xmj2+2d0)
         a22fak(mj2+j2p+1)=a2term*threej*(-1)**(xj2-xmj2)
* new
         threej=xf3j(xj2,2d0,xj2,-xmj2,0d0,xmj2)
         algfak=threej*(a2term/sqrt(2d0))*(-1)**(xj2-xmj2)
         if (xm.lt.0d0) then
            msign=-1
         else
            msign=1
         endif
         if (mflag) then
           if (mj1.eq.-j1p .and. mj2.eq. -j2p) then
              write (2,331)
              if (iprint) write (6,331)
331           format('%',4x,'F-REAL (first line)',7x,
     :         'F-IMAG (second line); NOT divided by (2j+1)k^2 factor')
           endif
           write(m1string,'(i1)') abs(mj1)
           if (mj1.ge.0)
     :        amplstring='fm1_'//m1string
           if (mj1.lt.0)
     :        amplstring='fm1_'//'m'//m1string
           if (mj2.eq.-j2p) then
               write (2,333) amplstring
               if(iprint) write (6,333) amplstring
           endif
333        format((a),'=[')
         endif
* Comment(JK): Loop over DCS angular grid
         aangle=ang1
         do 339 i=1,nangle
         ii=ii+1
* space frame (z-axis is initial velocity vector) scattering amplitude
* returned in q,  ordering of loops:
*      inner loop:  angle
*      middle loop:  mj2
*      outer loop:  mj1
* can save m-resolved amplitudes separately (no longer done 9/23/10)
*        if (mflag) then
*           if (iprint)
*    :      write (6,336) aangle,faksq*dreal(q(ii)),faksq*imag(q(ii))
*           write (2,337) aangle,faksq*dreal(q(ii)),faksq*imag(q(ii))
336         format(1x,f7.2,2g15.4)
337         format(1x,f7.2,2g15.4)
*        endif
         sn=sin(aangle*pi/180d0)
* here for steric effect
         if (stflag) then
            stampl=alph1*q(ii)+msign*alphm1*qm(ii)
            stamplm=alph1*q(ii)-msign*alphm1*qm(ii)
            if (msteric.ge.0 .and. abs(xm).ne.(msteric+0.5d0)) then
* REPLACED 10/22/99
*           if (msteric.ge.0 .and. mj1.ne.msteric) then
                stampl=0d0
                stamplm=0d0
            endif
            term=dreal(stampl*conjg(stampl))
            termm=dreal(stamplm*conjg(stamplm))
            s(i)=s(i)+dreal(stampl*conjg(stampl))
            sm(i)=sm(i)+dreal(stamplm*conjg(stamplm))
            xint=xint+sn*term
            xintm=xintm+sn*termm
*            xint=xint+sn*dreal(stampl*conjg(stampl))
*            xintm=xintm+sn*dreal(stamplm*conjg(stamplm))
         else
            xintmdep(indm)=xintmdep(indm)+sn*dreal(q(ii)*conjg(q(ii)))
            dsigterm=dreal(q(ii)*conjg(q(ii)))
            s(i)=s(i)+dsigterm
* accumulate Re[f(j1m1->j2m2)f(j1m1->j2,m2+2)]+Re[f(j1m1->j2m2)f(j1m1->j2,m2+2)]
            fm1m2(mj2+j2p+1,i)=q(ii)
            rho(mj2+j2p+1,i)=rho(mj2+j2p+1,i)+dsigterm
*           print *, 'mj1,mj2,mj2+j2p+1, fm1m2, rho(mj2+j2p+1,i):  ',
*    :         mj1,mj2, mj2+j2p+1,fm1m2(mj2+j2p+1,i),
*    :         rho(mj2+j2p+1,i)
            sm(i)=sm(i)+algfak*dsigterm
            sm6(i)=sm6(i)+octupfak*dsigterm
         endif
         aangle=aangle+dang
339      continue
340   continue
c       print *, 'mj1 is:  ', mj1
      if (j2.gt.1) then
         do 342 mj2=-j2p,j2-2
            do 341 i=1,nangle
c            print *, ' fm1m2(mj2+j2p+1,i),fm1m2(mj2+j2p+3,i):  ',
c     :                   fm1m2(mj2+j2p+1,i),fm1m2(mj2+j2p+3,i)
            term=
     :            (dreal(fm1m2(mj2+j2p+1,i))*dreal(fm1m2(mj2+j2p+3,i))+
     :             dimag(fm1m2(mj2+j2p+1,i))*dimag(fm1m2(mj2+j2p+3,i)))
            rho2(mj2+j2p+1,i)=rho2(mj2+j2p+1,i)+term
            a22(i)=a22(i)+a22fak(mj2+j2p+1)*term
c            print *, 'mj1,mj2,term,a22fak(mj2+j2p+1):  ',
c     :     mj1,mj2,term,a22fak(mj2+j2p+1)
341         continue
342      continue
      endif
      if (mflag) then
         aangle=ang1
         do i=1,nangle
* print out real and imaginary parts of scattering amplitudes
            write (2,344) aangle,(dreal(fm1m2(jj+j2p+1,i)),jj=-j2p,j2)
            write (2,344) aangle,(dimag(fm1m2(jj+j2p+1,i)),jj=-j2p,j2)
            aangle=aangle+dang
         enddo
         write (2,345)
         if (iprint) write (6,345)
      endif
343   continue
344   format(f8.2,26(1pg15.4))
345   format('];')


      write (2,346)
      if (mflag) write (3,346)
346   format('  ')
      if (.not.stflag) then
         write (2,348)
         if (iprint) write (6,347)
347      format
     :  ('    DEGENERACY AVERAGED DXSC (ANG^2/SR) AND ',
     :       'A20, A40, AND A22+ MOMENTS')
348      format
     :  ('%   DEGENERACY AVERAGED DXSC (ANG^2/SR) AND ',
     :       'A20, A40, AND A22+ MOMENTS',/,'dcs=[')
         if (mflag) write (3,349)
349      format
     :  ('%   DIAGONAL (M-FINAL) DENSITY MATRIX (FIRST ROW)',
     :        ' SECOND SUPRA-DIAGONAL (M,M+2) DENSITY MATRIX (2ND ROW)',
     :        /,'rho=[')
         do 351 i=1,nangle
         if (iprint)
     :        write(6,350)
     :        angle,s(i)*fak,sm(i)/s(i),sm6(i)/s(i),a22(i)/s(i)
         write(2,350) angle,s(i)*fak,sm(i)/s(i),sm6(i)/s(i),a22(i)/s(i)
350      format(1x,f7.2,4g15.4)
         if (mflag) then
            write(3,352) angle,(rho(ij+j2p+1,i)/s(i),ij=-j2p,j2)
            write(3,352) angle,(rho2(ij+j2p+1,i)/s(i),ij=-j2p,j2)
         endif
351      angle=angle+dang
352      format(f7.2,25g15.4)
      else
         write (2,360)
         if (iprint) write (6,360)
360      format
     :  ('    DEGENERACY AVERAGED STERIC DXSC''S: HEADS AND TAILS')
         do 370 i=1,nangle
         if (iprint) write(6,350) angle,0.5d0*s(i)*fak,0.5d0*sm(i)*fak
         write(2,361) angle,0.5d0*s(i)*fak,0.5d0*sm(i)*fak
361      format(1x,'%',f7.2,3g15.4)
370      angle=angle+dang
      endif
*      ang1=angle
      ang1=angle-dang
c
c.....loop back if not all required angles are finished
c
      if(ang1.lt.ang2-0.001d0) then
         call rdhead(1,cdate1,ered1,rmu1,csflg1,flghf1,
     1   flgsu1,
     1   twomol,nucros,jfirst,jfinal,jtotd,numin,numax,nud,
     1   nlevel,nlevop,nnout,jlev,inlev,elev,jout1)
         ang1=ang1+dang
         goto 200
      end if
* determine integral m-dependent cross sections

      if (mflag) then
         indm=0
         write(6,375) ang0,dang,ang2
         write(2,376) ang0,dang,ang2
375      format
     :   (/,'    M-DEPENDENT (COLLISION FRAME) INTEGRAL CROSS SECTIONS',
     :    /,9x,'ANGULAR RANGE:',f6.2,':',f5.2,':',f6.2,
     :   /,'       M    M''    XSC (ANG^2)')
376      format
     :   (/,'%   M-DEPENDENT (COLLISION FRAME) INTEGRAL CROSS SECTIONS',
     :    /,9x,'ANGULAR RANGE:',f6.2,':',f5.2,':',f6.2,
     :   /,'       M    M''    XSC (ANG^2)')
         algn=0d0
         xsctot=0d0
         do 385 mj1=-j1p,j1
         do 384 mj2=-j2p,j2
            indm=indm+1
            if (flaghf) then
               xmj1=mj1+0.5d0
               xmj2=mj2+0.5d0
            else
               xmj1=mj1
               xmj2=mj2
            endif
c     (3m^2-1)/(j*(j+1))
            algfak=(3d0*xmj2**2/(xj2*(xj2+1d0))-1d0)
            xintmdep(indm)=xintmdep(indm)*fak*dang*2d0*pi*pi/180d0
            xsctot=xsctot+xintmdep(indm)
            algn=algn+algfak*xintmdep(indm)
* correct for mj degeneracy factor of initial state
            xintmdep(indm)=xintmdep(indm)*ideg1
            if (flaghf) then
               write (6,378) xmj1,xmj2,xintmdep(indm)
               write (2,378) xmj1,xmj2,xintmdep(indm)
378            format(4x,2f6.1,g13.4)
            else
               write (6,379) mj1,mj2,xintmdep(indm)
               write (2,379) mj1,mj2,xintmdep(indm)
379            format(4x,2i5,g13.4)
            endif
384      continue
385      continue
         write (2,387) xsctot, algn/xsctot
         write (6,386) xsctot, algn/xsctot
386      format(/,'    DEG. AVER. XSC =',g12.3,'; ALIGNMENT =',f6.3)
387      format(/,'%   DEG. AVER. XSC =',g12.3,'; ALIGNMENT =',f6.3)

      endif
* determine integral oriented (steric) cross sections
      if (stflag) then
         xint=0.5d0*fak*xint*2d0*pi*dang*pi/180d0	
         xintm=0.5d0*fak*xintm*2d0*pi*dang*pi/180d0	
         write (6,390) ang0,dang,ang2,xint,xintm,
     :            100d0*(xint-xintm)/(xint+xintm)
         write (2,391) ang0,dang,ang2,xint,xintm,
     :            100d0*(xint-xintm)/(xint+xintm)
390   format (/,
     : '    INTEGRAL ORIENTED CROSS SECTIONS; ANGLES:',f6.2,':',f5.2,
     :   ':',f6.2,/,'    XSC-HEADS =',g13.4,'  XSC-TAILS =',g13.4,
     :   '    ASYMMETRY(%) =',f8.2)
391   format(/,'%   DEG. AVER. XSC =',f8.3,'; ALIGNMENT =',f6.3)
      endif
*
*  molecule-molecule collisions (ibasty=9)
*
*  compute degeneracy averaged cross sections only
      else
        ii = 0
        j1_i = j1/10
        j2_i = mod(j1,10)
        j1_f = j2/10
        j2_f = mod(j2,10)
        ideg1 = (2*j1_i + 1)*(2*j2_i + 1)
        fak = ang2c/(ideg1*ca**2)
        do 1500 mj1_i = -j1_i, j1_i
        do 1500 mj2_i = -j2_i, j2_i
        do 1500 mj1_f = -j1_f, j1_f
        do 1500 mj2_f = -j2_f, j2_f
          do 1400 i = 1, nangle
            ii =ii + 1
            dsigterm = dreal(q(ii) * conjg(q(ii)))
            s(i) = s(i) + dsigterm
1400      continue
1500    continue
*
        write(2,1348)
        if (iprint) write(6,1347)
1347    format(/'   DEGENERACY AVERAGED DXSC (ANG^2/SR)')
1348    format(/'%  DEGENERACY AVERAGED DXSC (ANG^2/SR)'/'dcs = [')
        angle = ang1
        do 1351 i = 1, nangle
          write(2,1350) angle, s(i)*fak
          if (iprint) write(6,1350) angle, s(i)*fak
1350      format(1x,f7.2,1g15.4)
          angle = angle + dang
1351    continue
      end if
*
500   call mtime(cpu1,ela1)
      cpu1 = cpu1 - cpu0
      ela1 = ela1 - ela0
      call gettim(cpu1,cpu)
      call gettim(ela1,elaps)
      write(6,720) elaps, cpu
      write(2,721) elaps, cpu
720   format(/,
     : ' ** DIFFERENTIAL CROSS SECTION CALCULATION FINISHED:',
     :       /,'    ELAPSED TIME:',(a),'  CPU TIME: ',(a))
721   format(/,'];',/
     : '% ** DIFFERENTIAL CROSS SECTION CALCULATION FINISHED:',
     :       /,'%   ELAPSED TIME:',(a),'  CPU TIME: ',(a))
      close(1)
      close(2)
      if (mflag) then
         write(3,721) elaps, cpu
         close(3)
      endif
      return
      end
* -----------------------------------------------------------------------
      subroutine ampli(j1,in1,j2,in2,jtot,sreal,simag,mmax,jpack,lpack,
     :  ipack,length,jq,lq,inq,nopen,y,q,maxl2,nangle,ihomo,flaghf,
     :  is_j12)
csubr  calculates scattering amplitudes for given jtot and set
csubr  of angles
c
*  author h.-j. werner
*  modified to allow calculation for molecule-molecule collisions
*  (ibasty=9):  1-feb-2012 by p. dagdigian
*
*  current revision date:  1-feb-2012 by p.dagdigian
*
c.....jpack,lpack,ipack: labels for rows
c.....jq,lq,inq:         labels for columns
*
      implicit double precision (a-h,o-z)
      complex*16 q,ai,fak2,fak3,yy,tmat
      parameter (zero=0.0d0, one=1.0d0, two=2.0d0)
      logical ihomo,flaghf,elastc,is_j12
      common /coj12/ j12(1)
      common /coj12p/ j12pk(1)
      dimension jpack(1),lpack(1),ipack(1),jq(1),lq(1),inq(1),q(1)
      dimension sreal(mmax,1),simag(mmax,1),y(1)
      dimension fak1(100),fak2(100),fak3(100),ilab1(100)
      sqpi=1.772453850905516d0
c
      ai=cmplx(zero,one)
      elastc=j1.eq.j2.and.in1.eq.in2
c
      if(flaghf) then
c.....here for half-integer spin
        fakj=sqpi*(two*dble(jtot) + two)*(-1)**(j1+j2+1)
        spin=0.5d0
        j1p=j1+1
        j2p=j2+1
      else
c.....here for integer spin
        spin=0.0d0
        if (.not. is_j12) then
          fakj=sqpi*(two*dble(jtot) + one)*(-1)**(j1+j2)
          j1p=j1
          j2p=j2
        else
          j1_i = j1/10
          j2_i = mod(j1,10)
          j1_f = j2/10
          j2_f = mod(j2,10)
          fakj = sqpi*(two*dble(jtot) + one)
     :        *(-1)**(j1_i + j1_f + j2_i + j2_f)
        end if
      end if
      xjtot=dble(jtot) + spin
      if (.not. is_j12) then
        xj1=dble(j1)+spin
        xj2=dble(j2)+spin
      else
        xj1_i = j1_i
        xj2_i = j2_i
        xj1_f = j1_f
        xj2_f = j2_f
      end if
      ll=0
      do 50 ilab=1,length
      if(jpack(ilab).ne.j1.or.ipack(ilab).ne.in1) goto 50
      l1=lpack(ilab)
      ll=ll+1
      fak1(ll)=fakj*sqrt(two * dble(l1) + one)
      ilab1(ll)=ilab
50    continue
      llmax=ll
c
      do 500 jlab=1,nopen
      if(jq(jlab).ne.j2.or.inq(jlab).ne.in2) goto 500
      l2=lq(jlab)
      xl2=l2
      if (is_j12) then
        j12_f = j12(jlab)
        xj12_f = j12_f
      end if
      do 60 ll=1,llmax
      ilab=ilab1(ll)
      l1=lpack(ilab)
      if (is_j12) j12_i = j12pk(ilab)
c.....convert to t-matrix
      tmat=-cmplx(sreal(jlab,ilab),simag(jlab,ilab))
      if (.not.is_j12) then
        if (elastc .and. l1.eq.l2) tmat=tmat+1.0d0
      else
        if (elastc .and. l1.eq.l2 .and.
     :    j12_i.eq.j12_f) tmat=tmat+1.0d0
      end if
      fak2(ll)=cmplx(fak1(ll)*(-1)**(l1+l2),zero)*(ai**(l1-l2))*tmat
60    continue
*
*  summation over magnetic quantum numbers
      if (.not. is_j12) then
*  atom-molecule case here
        ii=0
        do 400 mj1=-j1p,j1
        xmj1=dble(mj1)+spin
c
        do 70 ll=1,llmax
        ilab=ilab1(ll)
        xl1=lpack(ilab)
70      fak3(ll)=fak2(ll)*xf3j(xj1,xl1,xjtot,xmj1,zero,-xmj1)
c
        do 300 mj2=-j2p,j2
        xmj2=dble(mj2)+spin
        ml2=mj1-mj2
        iyof=(iabs(ml2)*maxl2+l2)*nangle
        xml2=ml2
        fak=xf3j(xj2,xl2,xjtot,xmj2,xml2,-xmj1)
        if(ml2.gt.0) fak=fak*(-1)**ml2
c
        do 200 iang=1,nangle
        yy=fak*y(iyof+iang)
        ii=ii+1
c
        do 100 ll=1,llmax
100     q(ii)=q(ii)+fak3(ll)*yy ! l (jk)
200     continue ! angle (jk
300     continue ! mj2 (jk)
400     continue ! mj1 (jk)
*
*  molecule-molecule systems
      else
        ii = 0
        do 1400 mj1_i = -j1_i, j1_i
        do 1400 mj2_i = -j2_i, j2_i
          xmj1_i = mj1_i
          xmj2_i = mj2_i
          mj12_i = mj1_i + mj2_i
          xmj12_i = mj12_i
c
          do 1070 ll = 1, llmax
            ilab = ilab1(ll)
            xl1 = lpack(ilab)
            j12_i = j12pk(ilab)
            xj12_i = j12_i
            fak3(ll) = fak2(ll) * (-1)**j12_i
     :        * sqrt(two * xj12_i + one)
     :        * xf3j(xj1_i,xj2_i,xj12_i,xmj1_i,xmj2_i,-xmj12_i)
     :        * xf3j(xj12_i,xl1,xjtot,xmj12_i,zero,-xmj12_i)
1070      continue
c
          do 1300 mj1_f = -j1_f, j1_f
          do 1300 mj2_f = -j2_f, j2_f
            xmj1_f = mj1_f
            xmj2_f = mj2_f
            mj12_f = mj1_f + mj2_f
            xmj12_f = mj12_f
            ml2 = mj12_i - mj12_f
            xml2 = ml2
            iyof = (iabs(ml2) * maxl2 + l2) * nangle
            fak = (-1)**(j12_f + ml2)
     :        * sqrt(two * xj12_f + one)
     :        * xf3j(xj1_f,xj2_f,xj12_f,xmj1_f,xmj2_f,-xmj12_f)
     :        * xf3j(xj12_f,xl2,xjtot,xmj12_f,xml2,-xmj12_i)
            if (ml2.gt.0) fak = fak * (-1)**ml2
c
            do 1200 iang = 1, nangle
              yy = fak * y(iyof + iang)
              ii = ii + 1
c
              do 1100 ll = 1, llmax
                q(ii) = q(ii) + fak3(ll) * yy
1100          continue
1200        continue
1300      continue
1400    continue
      end if
500   continue ! jlab (jk)
      return
      end
* -----------------------------------------------------------------------
      subroutine sphn(m,lmax,theta,yr,incy)
c
c  subroutine to calculate the
c  spherical harmonics y  (theta,0) for  m .le. l .le. lmax
c
c  -------------------------------------------------------------------
c  variables in call list:
c    m:     magnetic projection quantum number
c    lmax:  maximum value of l (minimum value of l is m)
c    theta: polar angle
c    yr:    on return: array containing real part of spherical harmonic
c    results in yr(l*incy+1) for given l
c    for l values less than m zero is returned
c
c  -------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      dimension yr(1)
      mm = iabs(m)
c  determine array of associated legendre polynomials
      call plm(mm,lmax,theta,yr,incy)
c
c                      (l-mm)!  mm
c  on return:  yr(j) = ------- p        [cos(theta)]
c                      (l+mm)!  l=mm+j-1
c     fpi = sqrt(1 / 4 * pi)
      fpi = 2.820947917738781d-01
      if (m .lt. 0) go to 5
c  here for positive m
      a = (( - 1.d0) ** m) * fpi
      go to 10
c  here for negative m
5     a = fpi
10    ll=1
      do 11  l = 0, mm-1
      yr(ll) = 0
11    ll=ll+incy
      do 15  l = mm, lmax
      fact = sqrt(2.d0 * l + 1.d0)
      yr(ll) = fact * yr(ll) * a
15    ll = ll + incy
      return
      end
* -----------------------------------------------------------------------
      subroutine plm(m,lmax,theta,p,incp)
c
c  generates alexander-legendre polynomials for m.le.l.le.lmax
c
      implicit double precision (a-h,o-z)
      dimension p(1)
      data zero, one,  two,        rad
     :     /0.d0, 1.d0, 2.d0, 57.29577951308232d0/
      x=cos(theta/rad)
      ll = m*incp + 1
      if (m.ge.0) go to 1
      write (6,100)
100   format('  NEGATIVE M IN LEGENDRE ROUTINE:  ABORT')
      call exit
1     if (m.gt.0) go to 5
c  here for regular legendre polynomials
      p(ll)=one
      ll=ll+incp
      pm1=one
      pm2=zero
      do 2 l=1,lmax
      pp=((two*l-one)*x*pm1-(l-one)*pm2)/dble(l)
      p(ll)=pp
      ll=ll+incp
      pm2=pm1
2     pm1=pp
      return
c
c  here for alexander-legendre polynomials
c
5     imax=2*m
      rat=one
      do 6 i=2,imax,2
      ai=i
6     rat=rat*((ai-one)/ai)
      y=sin(theta/rad)
      pm1=sqrt(rat)*(y**m)
      p(ll)=pm1
      ll=ll+incp
      pm2=zero
      low=m+1
      do 10 l=low,lmax
      al=(l+m)*(l-m)
      al=one/al
      al2=((l+m-1)*(l-m-1))*al
      al=sqrt(al)
      al2=sqrt(al2)
      pp=(two*l-one)*x*pm1*al-pm2*al2
      p(ll)=pp
      ll=ll+incp
      pm2=pm1
10    pm1=pp
      return
      end
*  -------------------------------------------------------------
      subroutine difs(fname1,fname2,ienerg,iprint,acc,accmx,thrs,
     :  imx,jmx,ityp)
*  -------------------------------------------------------------
*   reads and compares two s-matrix files
*   fname1,fname: job names
*   ienerg: energy number
*   all s-matrices in first file are read
*   second file is searched for corresponding jtot
*   authors:  joachim werner and millard alexander
*   current revision date 19-mar-1996
*  ------------------------------------------------------------
      implicit double precision (a-h,o-z)
      character*(*) fname1,fname2
      character*20 cdate1,cdate2
      character*40 xnam1,xnam2
      character*48 potnam1,potnam2,label1,label2

      logical existf,csflg1,csflg2,flghf1,flghf2,flgsu1,flgsu2
      logical twoml1,twoml2,nucr1,nucr2
      include "common/parpot"
      common /coz/ sreal1(1)
      common /cow/ sreal2(1)
      common /cozmat/ simag1(1)
      common /coamat/ simag2(1)
      common /cojq/ jq(1)
      common /colq/ lq(1)
      common /coinq/ inq(1)
      common /cojhld/ jout1(1)
      common /coehld/ jout2(1)
      common /coinhl/ jlev(1)
      common /coisc1/ inlev(1)
      common /cosc1/ elev(1)
      common /cosc2/ jpack1(1)
      common /cosc3/ jpack2(1)
      common /cosc4/ lpack1(1)
      common /cosc5/ lpack2(1)
      common /coisc2/ ipack1(1)
      common /coisc3/ ipack2(1)
      common /codim/ mairy,mmax
c
      zero=0
      acc=0
      accmx=0
      imx=0
      jmx=0
      ityp=0
      call gennam(xnam1,fname1,ienerg,'smt',lenx1)
      inquire (file=xnam1(1:lenx1), exist=existf)
      if (.not. existf) then
        write (6, 20) xnam1(1:lenx1)
20      format(/' FILE ',(a),' NOT FOUND')
        return
      end if
      call gennam(xnam2,fname2,ienerg,'smt',lenx2)
      inquire (file=xnam2(1:lenx2), exist=existf)
      if (.not. existf) then
        write (6, 20) xnam2(1:lenx2)
        return
      end if
      call openf(1,xnam1(1:lenx1),'tu',0)
      call openf(2,xnam2(1:lenx2),'tu',0)
      call rdhead(1,cdate1,
     1     ered1,rmu1,csflg1,flghf1,flgsu1,
     1   twoml1,nucr1,jfirst,jfinal,jtotd,numin,numax,nud,
     1   nlevel,nlevop,nnout1,jlev,inlev,elev,jout1)
      label1=label
      potnam1=potnam
      call rdhead(2,cdate2,
     !   ered2,rmu2,csflg2,flghf2,flgsu2,
     1   twoml2,nucr2,jfirst,jfinal,jtotd,numin,numax,nud,
     1   nlevel,nlevop,nnout2,jlev,inlev,elev,jout2)
      label2=label
      potnam2=potnam
      if (thrs .gt. zero) then
        label = 'modulus of S matrix'
        length = 19
      else
        label = 'S matrices'
        length = 10
      end if
      if(iprint.ge.1) then
        write(6,25) label(1:length), 'FIRST' ,xnam1(1:lenx1),
     1              cdate1,label1,potnam1,'SECOND',xnam2(1:lenx2),
     :              cdate2,label2,potnam2
25      format(/' COMPARE ',(a),/
     1    1x,(a),' FILE: ',(a)/
     1   ' WRITTEN:   ',(a)/
     1   ' LABEL:     ',(a)/
     1   ' POT NAME:  ',(a)//
     1    1x,(a),' FILE: ',(a)/
     1   ' WRITTEN:   ',(a)/
     1   ' LABEL:     ',(a)/
     1   ' POT NAME:  ',(a))
      end if
      idif=0
      if (rmu1.ne.rmu2) idif=idif+1
      if (ered1.ne.ered2) idif=idif+1
      if (nnout1.ne.nnout2) idif=idif+1
      if (csflg1.neqv.csflg2) idif=idif+1
      if (flghf1.neqv.flghf2) idif=idif+1
      if (flgsu1.neqv.flgsu2) idif=idif+1
      if (twoml1.neqv.twoml2) idif=idif+1
      do 26 i=1,iabs(nnout1)
26    if (jout1(i).ne.jout2(i)) idif=idif+1
c
30    call sread (0,sreal1, simag1, jtot1, jlpar1, nu1,
     :                  jq, lq, inq, ipack1, jpack1, lpack1,
     :                  1, mmax, nopen1, lengt1, ierr)
      if(ierr.eq.-1) goto 200
      if(ierr.lt.-1) then
        write(6,35) xnam1
35      format(' ERROR READING FILE ',(a))
        goto 200
      end if
      call sread (0,sreal2, simag2, jtot2, jlpar2, nu2,
     :                  jq, lq, inq, ipack2, jpack2, lpack2,
     :                  2, mmax, nopen2, lengt2, ierr)
      if(ierr.eq.-1) goto 200
      if(ierr.lt.-1) then
        write(6,35) xnam2
        goto 200
      end if
      if(nu1.ne.nu2) idif=idif+1
      if(jtot1.ne.jtot2) idif=idif+1
      if(jlpar1.ne.jlpar2) idif=idif+1
      if(lengt1.ne.lengt2) idif=idif+1
      do 60 i=1,lengt1
      if(jpack1(i).ne.jpack2(i)) idif=idif+1
      if(lpack1(i).ne.lpack2(i)) idif=idif+1
60    if(ipack1(i).ne.ipack2(i)) idif=idif+1
      if(idif.ne.0) then
        write(6,70) jtot1,jtot2
70      format(/' PARAMETERS NOT EQUAL FOR JTOT1=',i3,'  JTOT2=',i3)
        goto 200
      end if
      ncol=lengt1
      if(nnout1.lt.0) then
        if(nopen1.ne.nopen2) then
          write(6,80) nopen1,nopen2
80        format(/' NOPEN1.NE.NOPEN2 FOR NNOUT.LT.0:',
     1     '  NOPEN1=',i3,'  NOPEN2=',i3,'  NNOUT=',i2)
          call closf(1)
          call closf(2)
          return
        end if
        ncol=nopen1
      end if
      if(nnout1.gt.0) nopen1=0
      if (thrs .lt. zero) then
*  here for comparison of s matrices
        if(iprint.ge.1) write(6,90) 'real',jtot1,jlpar1,nu1
90      format(/' comparing ',a,' part of S matrices for jtot=',i3,
     1       '  jlpar=',i2,'  NU=',i3)
        call compar(sreal1,sreal2,mmax,lengt1,nopen1,
     1    erabs,errel,ermabs,ermrel,thrs,n,iprint,im,jm)
        acc=max(acc,abs(errel))
        if(abs(ermrel).gt.accmx) then
           accmx=abs(ermrel)
           imx=im
           jmx=jm
           ityp=1
        end if
        ij=(jm-1)*mmax+im
        if(iprint.ge.1) then
          write(6,100) erabs,ermabs,errel,ermrel,im,jm,
     1                 sreal1(ij),im,jm,sreal2(ij)
          write(6,90) 'IMAGINARY',jtot1,jlpar1,nu1
        end if
        call compar(simag1,simag2,mmax,lengt1,nopen1,
     1    erabs,errel,ermabs,ermrel,thrs,n,iprint,im,jm)
        acc=max(acc,abs(errel))
        if(abs(ermrel).gt.accmx) then
           accmx=abs(ermrel)
           imx=im
           jmx=jm
           ityp=2
        end if
        ij=(jm-1)*mmax+im
        if(iprint.gt.1) write(6,95)
95      format()
        if(iprint.ge.1)
     1    write(6,100) erabs,ermabs,errel,ermrel,im,jm,
     1                 simag1(ij),im,jm,simag2(ij), thrs
100     format(' average absolute difference: ',f11.8/
     1         ' largest absolute difference: ',f11.8/
     1         ' average relative difference: ',f10.2,'%'/
     1         ' largest relative difference: ',f10.2,'%'/
     1  ' S1(',i2,',',i2,') =',g12.4,'  S2(',i2,',',i2,') =',g12.4,/
     :  ' inspection threshold is ',1pg8.1)
      else
*  here for comparison of modulus of s-matrices
        if(iprint.ge.1) write(6,105) jtot1,jlpar1,nu1
105     format(/' moduli of S matrices for jtot=',i3,
     1       '  jlpar=',i2,'  NU=',i3)
        call compt2(sreal1,simag1,sreal2,simag2,mmax,lengt1,nopen1,
     1       erabs,errel,ermabs,ermrel,thrs,n,iprint,im,jm)
        acc=max(acc,abs(errel))
        if(abs(ermrel).gt.accmx) then
           accmx=abs(ermrel)
           imx=im
           jmx=jm
        end if
        ij=(jm-1)*mmax+im
        if (iprint .ge. 1)
     1    write(6,190) erabs,ermabs,errel,
     1    ermrel,im,jm,sqrt(simag1(ij)**2 + sreal1(ij)**2),im,jm,
     1    sqrt(simag2(ij)**2 + sreal2(ij)**2),thrs
190    format(/
     1  ' average absolute difference: ',f11.8/
     1  ' largest absolute difference: ',f11.8/
     1  ' average relative difference: ',f10.2,'%'/
     1  ' largest relative differencE: ',f10.2,'%'/
     1  ' mod(S1)(',i2,',',i2,') =',g12.4,
     :  ' mod(S2)(',i2,',',i2,') =',g12.4,/
     :  ' inspection threshold is ',1pg8.1)

      end if
      goto 30
200   call closf(1)
      call closf(2)
      return
      end
      subroutine compar(s1,s2,ndim,l1,n1,erabs,errel,ermabs,ermrel,
     1  thrs,n,iprint,im,jm)
      implicit double precision (a-h,o-z)
*   author: h.-j. werner
*   current revision date 23-sept-87
      dimension s1(ndim,1),s2(ndim,1)
      erabs=0
      errel=0
      ermabs=0
      ermrel=0
      ncol=l1
      if(n1.ne.0) ncol=n1
      n=0
      m=0
      do 100 i=1,ncol
      je=i
      if(n1.ne.0) je=l1
      jee=min0(6,je)
      if(iprint.gt.1) then
        write(6,10)
        write(6,10) (s1(i,j),j=1,jee)
        write(6,10) (s2(i,j),j=1,jee)
10      format(1x,6g12.4)
      end if
      do 100 j=1,je
      n=n+1
      er=abs(s1(i,j)-s2(i,j))
      erabs=erabs+er
      if(er.gt.ermabs) ermabs=er
      if(abs(s1(i,j)).lt.thrs) goto 100
      m=m+1
      er=2.0d0*er/(abs(s1(i,j))+abs(s2(i,j)))
      if(er.gt.ermrel) then
        ermrel=er
        im=i
        jm=j
      end if
      errel=errel+er
100   continue
      n=max0(n,1)
      m=max0(m,1)
      erabs=erabs/n
      errel=100.d0*errel/m
      ermrel=100.d0*ermrel
      return
      end
* -----------------------------------------------------------------------
      subroutine compt2(s1r,s1i,s2r,s2i,ndim,l1,n1,erabs,errel,
     1  ermabs,ermrel,thrs,n,iprint,im,jm)
      implicit double precision (a-h,o-z)
      dimension s1r(ndim,1),s2r(ndim,1)
      dimension s1i(ndim,1),s2i(ndim,1)
      erabs=0
      errel=0
      ermabs=0
      ermrel=0
      ncol=l1
      if(n1.ne.0) ncol=n1
      n=0
      m=0
      do 100 i=1,ncol
      je=i
      if(n1.ne.0) je=l1
      jee=min0(6,je)
      if(iprint.gt.1) then
        write(6,10)
        write(6,10) (sqrt(s1r(i,j)**2+ s1i(i,j)**2),j=1,jee)
        write(6,10) (sqrt(s2r(i,j)**2+ s2i(i,j)**2),j=1,jee)
10      format(1x,6g12.4)
      end if
      do 100 j=1,je
      n=n+1
      s1mod = sqrt((s1r(i,j))**2 + s1i(i,j)**2)
      s2mod = sqrt((s2r(i,j))**2 + s2i(i,j)**2)
      if(s1mod.gt.thrs .and. s2mod.gt.thrs) then
        er=abs(s1mod - s2mod)
        erabs=erabs+er
        if(er.gt.ermabs) ermabs=er
        m=m+1
        er=2.0d0*er/(s1mod + s2mod)
        if(er.gt.ermrel) then
          ermrel=er
          im=i
          jm=j
        end if
        errel=errel+er
      end if
100   continue
      n=max0(n,1)
      m=max0(m,1)
      erabs=erabs/n
      errel=100.d0*errel/m
      ermrel=100.d0*ermrel
      return
      end
*  -------------------------------------------------------------
