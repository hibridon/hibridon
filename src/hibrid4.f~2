************************************************************************
*                                                                       *
*                         hibridon 4  library                           *
*                                                                       *
*************************************************************************
*                          routines included:                           *
*                                                                       *
*   2. sprint         prints s-matrices on the screen                   *
*   3. spropn         this subroutine calculates the diagonal matrices  *
*                     to propagate the log-derivative matrix through    *
*                     the current interval                              *
*   4. steppr         determines matrix to transform log-deriv matrix   *
*                     into new interval                                 *
*   5. transp         subroutine to carry out in place transposition    *
*                     of n x n matrix a                                 *
*   6. turn           function, determines classical turning point      *
*   7. wavevc         sets up wavevector matrix and diagonalizes it     *
*   8. xwrite         subroutine to write out integral cross sections   *
*   9. waverd         writes and reads header file for wavefunction     *
*  10. psiasym/psi    to determine wavefunction
*  11. flux           to determine fluxes
*  12. transmt        print out transformation matrix at rout
*************************************************************************
* ----------------------------------------------------------------------
      subroutine sprint (fname, ia)
*   reads and prints s-matrices
*   author: h.-j. werner
*   now print out j12 for molecule-molecule systems
*   current revision date: 24-jan-2012 by p.dagdigian
* ----------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      character*(*) fname
      character*20 cdate
      character*40 xname
      logical  existf, csflag, flaghf, flagsu, twomol, nucros
      dimension ia(4)
      include "common/parpot"
      common /coz/ sreal(1)
      common /cozmat/ simag(1)
      common /cojq/ jq(1)
      common /colq/ lq(1)
      common /coinq/ inq(1)
      common /coj12/ j12(1)
      common /coinhl/ jlev(1)
      common /cosc1/ elev(1)
      common /coisc2/ jpack(1)
      common /coisc3/ lpack(1)
      common /coj12p/ j12pk(1)
      common /cosout/ nnout, jout(21)
      common /coisc1/ inlev(1)
      common /coisc4/ ipack(1)
      common /codim/ nairy, nmax
      common /coconv/ econv, xmconv
      common /coselb/ ibasty

c
c.....jtota: first jtot to be printed
c.....jtotb: last jtot to be printed
c.....jlp:   jlpar to be printed. if zero, both parities are searched
c.....ienerg: number of energy
      jtota = ia(1)
      jtotb = ia(2)
      jlp = ia(3)
      ienerg = ia(4)
      if(ienerg.eq.0) ienerg = 1
      if(jtotb.eq.0) jtotb = jtota
      call gennam(xname, fname, ienerg, 'smt', lenx)
      inquire (file = xname,  exist = existf)
      if (.not. existf) then
        write (6,  20) xname(1:lenx)
20      format(/' FILE ', (a), ' NOT FOUND')
        return
      end if
      call openf(1, xname, 'tu', 0)
      call rdhead(1,cdate,
     1   ered,rmu,csflag,flaghf,flagsu,twomol,
     1   nucros,jfirst,jfinal,jtotd,numin,numax,nud,nlevel,nlevop,nnout,
     1   jlev,inlev,elev,jout)
        if(csflag) jlp=0
        write (6, 70) xname, cdate, label, potnam, ered*econv
70      format(/' S-MATRICES READ FROM FILE ', (a)/
     :          ' WRITTEN: ', (a), /, ' LABEL:   ', (a),/,
     :          ' POT NAME:  ', (a)
     :         /,' ENERGY: ', f10.3)
        if (.not. twomol) then
          write (6, 80)
80        format ('   N   J   INDEX   EINT(CM-1)')
          do  95  i  =  1,  nlevop
            if (ibasty.ne.12) then
              if (.not. flaghf) then
                write (6,  85) i,  jlev(i),  inlev(i),  elev(i) * econv
85              format (i4,  i5,  i6,  f11.3)
              else
                write (6,  90) i,  (jlev(i)+0.5d0),  inlev(i),
     :                           elev(i) * econv
90              format (i4,  f5.1,  i6,  f11.3)
              end if
            else
              write (6,91) i, jlev(i),inlev(i)+0.5,elev(i)*econv
91            format (i4,i5,f6.1,f11.3)
            endif
95        continue

        else
          write (6, 100)
100       format('   N   J1   J2  INDEX  EINT(CM-1)')
            do 135  i  =  1,  nlevop
              jj1 = jlev(i) / 10
              jj2 = mod(jlev(i), 10)
              write (6,  130) i,  jj1,  jj2,  inlev(i),
     :                        elev(i) * econv
130           format (i4,  2i5,  i6,  f11.3)
135         continue
        end if
      jtotb = min0(jtotb, jfinal)
*
      iadr=0
30    call sread (iadr, sreal, simag, jtot, jlpar, nu,
     :                  jq, lq, inq, ipack, jpack, lpack,
     :                   1, nmax, nopen, length, ierr)
      if(csflag) jlpar=0
      if(ierr.eq.-1) goto 400
      if(ierr.lt.-1) then
        write(6,35) xname
35      format(' ERROR READING FILE ',(a))
        goto 400
      end if
c.....assume that jlpar=1 is stored first
220   if (jlpar .eq.1.and.jlp.eq.-1) goto 30
      if(jtot.lt.jtota) goto 30
      if(jtot.gt.jtotb) then
         if(jlp.eq.jlpar.or.jlp.eq.-1) goto 400
         jlp=-1
         goto 220
      end if
      if (.not.flaghf) then
        write (6, 230) jtot, jlpar, nu, nnout
230     format(/' JTOT=', i4, '  JLPAR=', i2, '  NU=', i3,
     :          '  NNOUT=', i3)
      else
        write (6, 240) jtot+0.5d0, jlpar, nu+0.5d0, nnout
240     format(/' JTOT=', f6.1, '  JLPAR=', i2, '  NU=', f5.1,
     :          '  NNOUT=', i3)
      end if
      if (nnout.le.0) then
        write (6, 250)
250     format(/' COLUMN INDICES:')
        write (6, 290) 'N    ', (j, j=1, nopen)
        if (.not. twomol) then
          if (flaghf) then
            write (6, 260) 'J    ', (jq(j)+0.5d0, j=1, nopen)
260         format (1x, (a), (t10, 20(f6.1)) )
          else
            write (6, 290) 'J    ', (jq(j), j=1, nopen)
          end if
        else
          write (6, 270) 'J1/J2', (jq(j), j=1, nopen)
270       format(1x, (a), (t10, 10i6) )
        end if
        write (6, 290) 'L    ', (lq(j), j=1, nopen)
        write (6, 290) 'INDEX', (inq(j), j=1, nopen)
      end if
        write (6, 280)
280     format(/' ROW INDICES:')
        write (6, 290) 'N    ', (j, j=1, length)
        if (.not. twomol) then
          if (ibasty.eq.12) then
            write (6, 290) 'J    ', (jpack(j), j=1, length)
            write (6, 260) 'IS   ', (ipack(j)+0.5d0, j=1, length)
          else
            if (flaghf) then
              write (6, 260) 'J    ', (jpack(j)+0.5d0, j=1, length)
            else
              write (6, 290) 'J    ', (jpack(j), j=1, length)
            end if
            write (6, 290) 'IS   ', (ipack(j), j=1, length)
          endif
        else
          write (6, 270) 'J1/J2', (jpack(j), j=1, length)
          write (6, 270) 'J12', (j12pk(j), j=1, length)
          write (6, 270) 'IS', (ipack(j), j=1, length)
        end if
        write (6, 290) 'L    ', (lpack(j), j=1, length)
290     format(1x, (a), (t10, 10i6))
      ncol = nopen
      if(nnout.gt.0) ncol = length
      write (6, 300) 'REAL PART OF THE S-MATRIX'
300   format(/1x, (a))
      do 330 ja = 1, length, 10
        je=min0(ja+9,length)
        write (6, 310) (j, j = ja, je)
310     format(10i12)
        ij=1-nmax
        do 320 i=1,ncol
          if(nnout.gt.0) je=min0(ja+9,i)
          if (je.ge.ja) write (6, 315) i, (sreal(ij+j*nmax), j=ja,je)
315       format(1x, i3, 10(1pe12.4))
320     ij=ij+1
330   continue
      write (6, 300) 'IMAGINARY PART OF THE S-MATRIX'
      do 350 ja = 1, length, 10
        je=min0(ja+9,length)
        write (6, 310) (j, j = ja, je)
        ij=1-nmax
        do 340 i = 1, ncol
          if(nnout.gt.0) je=min0(ja+9,i)
          if (je.ge.ja) write (6, 315) i, (simag(ij+j*nmax), j=ja,je)
340     ij=ij+1
350   continue
      goto 30
400   call closf(1)
      close(1)
      return
      end
* -----------------------------------------------------------------------
      subroutine spropn (rnow, width, eignow, hp, y1, y4, y2,
     :                   gam1, gam2, nch)
*-----------------------------------------------------------------------------
*  this subroutine calculates the diagonal matrices to propagate the
*  log-derivative matrix through the current interval
*  also calculated are the ihomogeneous propagators (explained below)
*-----------------------------------------------------------------------------
*  variables in call list:
*    rnow:       midpoint of the current interval
*    width:      width of the current interval
*    eignow:     array containing the wavevectors
*                these are defined by eq. (6) of m.alexander,
*                j. chem. phys. 81,4510 (1984)
*    hp:         array containing the negative of diagonal elements of the
*                derivative of the wavevector matrix at the center of the
*                current interval [see eq. (9) of m.alexander,
*                j. chem. phys. 81,4510 (1984)
*                this array thus contains the derivative of the diagonal
*                elements of the transformed hamiltonian matrix
*    y1, y2, y4: on entry, contain the desired diagonal elements of the
*                homogeneous propagator
*    gam1, gam2: on return, if photof .true, contain the desired diagonal
*                elements of the ihomogeneous propagators
*                otherwise gam1 and gam2 are returned as zero
*    nch:        the number of channels, this equals the dimensions of the
*                eignow, hp, y1, y2, y2, gam1, and gam2 arrays
*-----------------------------------------------------------------------------
*  the key equations, reproduced below, are taken from
*  m. alexander and d. manolopoulos, "a stable linear reference potential
*  algorithm for solution ..."
*  each uncoupled equation can be written as:
*         2    2
*     [ d / dr + eignow - hp * r ] f(r) = 0
*     where r is the distance from the midpoint of the current interval
*  the linearly indepedent solutions are the airy functions ai(x) and bi(x)
*  where  x = alpha (r + beta)
*                   1/3
*  with   alpha = hp   , and beta = (-eignow) / hp
*  the three diagonal elements of the cauchy propagator necessary to propagate
*  the log-derivative matrix are:
*    b = pi [ ai(x ) bi(x ) - ai(x )bi(x ) ] / alpha
*                 1      2        2     1
*    a = pi [ - ai'(x ) bi(x ) + ai(x ) bi'(x ) ]
*                    1      2        2       1
*    d = pi [ ai(x ) bi'(x ) - ai'(x ) bi(x ) ]
*                 1       2         2      1
*    where x  = alpha ( beta + width / 2) and
*           2
*          x  = alpha ( beta - width / 2)
*           1
*  here "width" denotes the width of the interval
*  the diagonal elements of the "imbedding type" propagator are given in terms
*  of the diagonal elements of the cauchy propagator by:
*     y = a/b     y = y = 1/b    and   y = d/b
*      1           2   3                4
*  for the calculation sof the homogeneous propagators
*  the airy functions are defined in terms of their moduli and phases
*  for negative x these definitions are:
*      ai(-x) = m(x) cos[theta(x)]
*      bi(-x) = m(x) sin[theta(x)]
*      ai'(-x) = n(x) cos[phi(x)]
*      bi'(-x) = n(x) sin[phi(x)]
*  in other words
*          2              2        2
*      m(x)  = sqrt[ ai(x)  + bi(x)  ]
*          2               2         2
*      n(x)  = sqrt[ ai'(x)  + bi'(x)  ]
*      theta(x) = atan [ bi(x) / ai(x) ]
*      phi(x)   = atan [ bi'(x) / ai'(x) ]
*  for positive x the moduli and phases are defined by:
*      ai(x) = m(x) sinh[theta(x)]
*      bi(x) = m(x) cosh[theta(x)]
*      ai'(x) = n(x) sinh[phi(x)]
*      bi'(x) = n(x) cosh[phi(x)]
*  in other words
*          2              2        2
*      m(x)  = sqrt[ bi(x)  - ai(x)  ]
*          2               2         2
*      n(x)  = sqrt[ bi'(x)  - ai'(x)  ]
*      theta(x) = atanh [ ai(x) / bi(x) ]
*      phi(x)   = atanh [ ai'(x) / bi'(x) ]
*  here the the exponentially scaled airy functions
*  ai(x), ai'(x), bi(x), bi'(x) are:
*      ai(x)  = ai(x)  * exp[zeta]
*      ai'(x) = ai'(x) * exp[zeta]
*      bi(x)  = bi(x)  * exp[-zeta]
*      bi'(x) = bi'(x) * exp[-zeta]
*                          3/2
*      where zeta = (2/3) x
*  note that for positive x the phases are labeled chi and eta in
*  m. alexander and d. manolopoulos, "a stable linear reference potential
*  algorithm for solution ..."
*-----------------------------------------------------------------------------
*  for both x  and x  negative
*            1      2
*  (this corresponds to a channel which is classically open at both ends of th
*  interval)
*  we find:
*  y     = 1 / { m  m  sin[theta -theta ] }
*   2             1  2          2      1
*          n  sin[phi -theta ]
*           1        1      2
*  y    = ----------------------
*   1      m  sin[theta - theta ]
*           1          2       1
*          n  sin[phi -theta ]
*           2        2      1
*  y    = ----------------------
*   4      m  sin[theta - theta ]
*           2          2       1
*  here the subscripts 1 and 2 imply the moduli and phases evaluated at x = x
*                                                                            1
*  and x = x  , respectively
*           2
*-----------------------------------------------------------------------------
*  for both x  and x  positive
*            1      2
*  (this corresponds to a channel which is classically closed at both ends of
*  the interval)
*  we find:
*  1 / y  =  m  m  cosh[z -z ] { sinh[theta -theta ]
*       2     1  2       2  1              1      2
*                         + tanh[z -z ] sinh[theta +theta ] }
*                                 2  1            1      2
*                     3/2
*   where z  = (2/3) x     and similarly for z
*          1          1                       2
*          n  { sinh [theta -phi ] - tanh[z -z ] sinh[theta +phi ] }
*           1              2    1          2  1            2    1
*  y    = --------------------------------------------------------
*   1      m  { sinh [theta -theta ] + tanh[z -z ] sinh[theta +theta ] }
*           1              2      1          2  1            2      1
*          n  { sinh [theta -phi ] - tanh[z -z ] sinh[theta +phi ] }
*           2              1    2          2  1            1    2
*  y     = --------------------------------------------------------
*   4      m  { sinh [theta -theta ] + tanh[z -z ] sinh[theta +theta ] }
*           2              2      1          2  1            2      1
*-----------------------------------------------------------------------------
*  for x  positive and x  negative we find:
*       1               2
*  1 / y  = m  m  cosh[z ] cosh[theta ] { - cos[theta ] (1 + tanh[z ])
*       2    1  2       1            1               2             1
*                                   + tanh[theta ] sin[theta ] (1 - tanh[z ])
*                                               1           2             1
*      n { cos[theta ](1 + tanh[z ]) - tanh[phi ] sin[theta ] (1 - tanh[z ]) }
*       1           2            1             1           2             1
* y = ------------------------------------------------------------------------
*  1   m {-cos[theta ](1 + tanh[z ]) + tanh[theta ] sin[theta ] (1 - tanh[z ])
*       1           2            1               1           2             1
*      n {-cos[phi ](1 + tanh[z ]) + tanh[theta ] sin[phi ] (1 - tanh[z ]) }
*       2         2            1               1         2             1
* y  = -----------------------------------------------------------------------
*  4   m {-cos[theta ](1 + tanh[z ]) + tanh[theta ] sin[theta ] (1 - tanh[z ])
*       2           2            1               1           2             1
*-----------------------------------------------------------------------------
*  for x  negative and x  positive we find:
*       1               2
* 1 / y  = m  m  cosh[z ] cosh[theta ] { cos[theta ] (1 + tanh[z ])
*      2    1  2       2            2             1             2
*                                  - tanh[theta ] sin[theta ] (1 - tanh[z ]) }
*                                              2           1             2
*      n {-cos[phi ](1 + tanh[z ]) + tanh[theta ] sin[phi ] (1 - tanh[z ]) }
*       1         1            2               2         1             2
* y  = -----------------------------------------------------------------------
*  1   m {cos[theta ](1 + tanh[z ]) - tanh[theta ] sin[theta ] (1 - tanh[z ])
*       1          1            2               2           1             2
*      n { cos[theta ](1 + tanh[z ]) - tanh[phi ] sin[theta ] (1 - tanh[z ]) }
*       2           1            2             2           1             2
* y  = -----------------------------------------------------------------------
*  4   m {cos[theta ](1 + tanh[z ]) - tanh[theta ] sin[theta ] (1 - tanh[z ])
*       2          1            2               2           1             2
*-----------------------------------------------------------------------------
*  for the special case of a constant reference potential (hp=0)
*  then the propagators are:
*  for eignow .gt. 0 (the classically allowed region)
*    y1 = y4 = k cot (k width)
*    y2 = k / sin (k width)
*    where k = sqrt (eignow)
*  for eignow .lt. 0 (the classically forbidden region)
*    y1 = y4 = kap coth (kap width)
*    y2 = kap / sinh (kap width)
*
*    where kap = sqrt (-eignow)
*-----------------------------------------------------------------------------
*  this subroutine also calculates the diagona linhomogeneous log-derivative
*  propagators.  key equations are 9.13, 9.14, and 9.25 of the ph. d.
*  thesis of d. manolopoulos
*  the diagonal elements of the two inhomogeneous propagators are defined
*  in terms of the linearly intependent solutions psi+ and psi-, which
*  are
*  psi+ = [ - bi(x2)ai(x) + ai(x2)bi(x) ] y2 / w
*  and
*  psi- = [ - bi(x1)ai(x) + ai(x1)bi(x) ] y2 / w
*  where w is the wronskian (1/pi)
*  in the determination of these inhomogeneous propagators
*  the airy functions are defined as follows:
*  for negative x :
*      ai(-x) = ai(x) cos[th] + bi(x) sin[th]
*      bi(-x) = bi(x) cos[th] - ai(x) cos[th]
*                            3/2
*      where zeta = (2/3) |x|
*  for positive x :
*      ai(x) = exp(-zeta) ai(x)
*      bi(x) = exp(zeta) bi(x)

*  the integrals of the airy functions are defined as:

*  for a > 0
*      int[ai(x),{0,a}] = 1/3 - exp(-zeta)iai(a)
*      int[bi(x),{0,a}] = exp(zeta)ibi(a)
*  and for a < 0
*      int[ai(x),{a,0}] = int[ai(-x),{0,-a}]
*                       = 2/3 - q(a) cos(th) + p(a) sin(th)
*      int[bi(x),{a,0}] = int[bi(-x),{0,-b}] =
*                       = p(a) cos(th) + q(a) sin(th)
*  we further assume that the ground state wavefunction times the dipole
*  moment function can be expanded as phi(x) = phi0 + phi1 x
*  where phi1 = d[phi,rmid]/alpha and
*        phi0 = phi(rmid) - beta * d[phi,rmid]
*-----------------------------------------------------------------------------
*  for both x  and x  negative
*            1      2
*  (this corresponds to a channel which is classically open at both ends of th
*  interval)
*  we find:
*  y     = 1 / { m  m  sin[theta -theta ] }
*   2             1  2          2      1
*          n  sin[phi -theta ]
*           1        1      2
*  y    = ----------------------
*   1      m  sin[theta - theta ]
*           1          2       1
*          n  sin[phi -theta ]
*           2        2      1
*  y    = ----------------------
*   4      m  sin[theta - theta ]
*           2          2       1
*  here the subscripts 1 and 2 imply the moduli and phases evaluated at x = x
*                                                                            1
*  and x = x  , respectively
*           2
*-----------------------------------------------------------------------------
*  for both x  and x  positive
*            1      2
*  (this corresponds to a channel which is classically closed at both ends of
*  the interval)
*  we find:
*  1 / y  =  m  m  cosh[z -z ] { sinh[theta -theta ]
*       2     1  2       2  1              1      2
*                         + tanh[z -z ] sinh[theta +theta ] }
*                                 2  1            1      2
*                     3/2
*   where z  = (2/3) x     and similarly for z
*          1          1                       2
*          n  { sinh [theta -phi ] - tanh[z -z ] sinh[theta +phi ] }
*           1              2    1          2  1            2    1
*  y    = --------------------------------------------------------
*   1      m  { sinh [theta -theta ] + tanh[z -z ] sinh[theta +theta ] }
*           1              2      1          2  1            2      1
*          n  { sinh [theta -phi ] - tanh[z -z ] sinh[theta +phi ] }
*           2              1    2          2  1            1    2
*  y     = --------------------------------------------------------
*   4      m  { sinh [theta -theta ] + tanh[z -z ] sinh[theta +theta ] }
*           2              2      1          2  1            2      1
*-----------------------------------------------------------------------------
*  for x  positive and x  negative we find:
*       1               2
*  1 / y  = m  m  cosh[z ] cosh[theta ] { - cos[theta ] (1 + tanh[z ])
*       2    1  2       1            1               2             1
*                                   + tanh[theta ] sin[theta ] (1 - tanh[z ])
*                                               1           2             1
*      n { cos[theta ](1 + tanh[z ]) - tanh[phi ] sin[theta ] (1 - tanh[z ]) }
*       1           2            1             1           2             1
* y = ------------------------------------------------------------------------
*  1   m {-cos[theta ](1 + tanh[z ]) + tanh[theta ] sin[theta ] (1 - tanh[z ])
*       1           2            1               1           2             1
*      n {-cos[phi ](1 + tanh[z ]) + tanh[theta ] sin[phi ] (1 - tanh[z ]) }
*       2         2            1               1         2             1
* y  = -----------------------------------------------------------------------
*  4   m {-cos[theta ](1 + tanh[z ]) + tanh[theta ] sin[theta ] (1 - tanh[z ])
*       2           2            1               1           2             1
*-----------------------------------------------------------------------------
*  for x  negative and x  positive we find:
*       1               2
* 1 / y  = m  m  cosh[z ] cosh[theta ] { cos[theta ] (1 + tanh[z ])
*      2    1  2       2            2             1             2
*                                  - tanh[theta ] sin[theta ] (1 - tanh[z ]) }
*                                              2           1             2
*      n {-cos[phi ](1 + tanh[z ]) + tanh[theta ] sin[phi ] (1 - tanh[z ]) }
*       1         1            2               2         1             2
* y  = -----------------------------------------------------------------------
*  1   m {cos[theta ](1 + tanh[z ]) - tanh[theta ] sin[theta ] (1 - tanh[z ])
*       1          1            2               2           1             2
*      n { cos[theta ](1 + tanh[z ]) - tanh[phi ] sin[theta ] (1 - tanh[z ]) }
*       2           1            2             2           1             2
* y  = -----------------------------------------------------------------------
*  4   m {cos[theta ](1 + tanh[z ]) - tanh[theta ] sin[theta ] (1 - tanh[z ])
*       2          1            2               2           1             2
*-----------------------------------------------------------------------------
*  for the special case of a constant reference potential (hp=0)
*  then the propagators are:
*  for eignow .gt. 0 (the classically allowed region)
*    y1 = y4 = k cot (k width)
*    y2 = k / sin (k width)
*    where k = sqrt (eignow)
*  for eignow .lt. 0 (the classically forbidden region)
*    y1 = y4 = kap coth (kap width)
*    y2 = kap / sinh (kap width)
*
*    where kap = sqrt (-eignow)
*-----------------------------------------------------------------------------
*  written by:  millard alexander
*  current revision date:  30-dec-1994
*-----------------------------------------------------------------------------
      implicit double precision (a-h,o-z)
*      implicit none
      double precision a, b, bfact, cs, cs1, cs2, csh, dalph2, dalpha,
     :    darg, dbeta, dcay, delzet, denom, dhalf, dkap, dlzeta,
     :    dmmod1, dmmod2, dnmod1, dnmod2, doneth, dphi1, dphi2,
     :    dpi, droot, dslope, dthet1, dthet2, dtnhfm,
     :    dtnhfp, dx1, dx2, dzeta1, dzeta2, emz1, emz2,
     :    ez1, ez2, fact, oflow, one, rnow, scai1, scai2, scbi1, scbi2,
     :    sn, sn1, sn2, snh, tnhfac, width, x1, x2, xairy1, xairy2,
     :    xbiry1, xbiry2, zero
      double precision eignow, gam1, gam2, hp, q, y1, y2, y4
      double precision xinpt, fprop
      integer i, nch, mxphot, nphoto
      logical photof
      common /coqvec2/ q
      common /cophot/ photof
      dimension eignow(1), hp(1), y1(1), y2(1), y4(1), gam1(1), gam2(1)
      dimension q(1)
      data     doneth,        dhalf
     :  / 0.333333333333333d0, 0.5d0 /
      data zero, one /0.d0, 1.d0/
      data  dpi / 3.1415926535897932d0 /
*  the parameter oflow is the largest value of x for which exp(x)
*  does not cause a single precision overflow
*                                     n
*  a reasonable value is x = [ ln(2) 2 ] - 5, where n is the number of bits in
*  the characteristic of a floating point number
      data oflow / 83.d0 /
      if (.not. photof) then
       call dset(nch,zero,gam1,1)
       call dset(nch,zero,gam2,1)
      endif
*     now determine propagators for all nch channels
      do 10  i = 1, nch
        dslope = hp(i)
* activate next statement for constant reference potential
* force slope to equal zero, to force constant potential
*        dslope=0.d0
        darg = 1.e+10
        if (dslope .ne. 0.d0)
     :    darg = log (abs(eignow(i))) - log (abs(dslope))
        if (darg .gt. 20.d0 .or. width .lt. 1.d-5) then
*  here if the relative slope in the wavevector matrix is less than 1.**(-20)
*  in magnitude, or sector width less than 1.e-5 bohr,
*  in which case the potential is assumed to be constant
          if (eignow(i) .gt. 0) then
*  here for classically allowed region (sines and cosines as reference
*  solutions)
            dcay = sqrt (eignow(i))
            darg = dcay * width
            sn=sin(darg)
            y1(i) = dcay / tan (darg)
            y4(i) = y1(i)
            y2(i) = dcay / sn
*  here for inhomogeneous propagators
            if (photof) then
              cs=cos(darg)
              b=rnow+width*dhalf
              a=rnow-width*dhalf
              denom=dcay*sn
              fact=(one-cs)*(q(i)-q(nch+i)*rnow)
              gam1(i)=(fact+(b-a*cs-sn/dcay)*q(nch+i))/denom
              gam2(i)=(fact+(a-b*cs+sn/dcay)*q(nch+i))/denom
            endif
          else
*  here for classically forbidden region (hyperbolic sines and cosines as
*  reference solutions)
            dkap = sqrt ( - eignow(i))
            darg = dkap * width
            snh=sinh(darg)
            y1(i) = dkap / tanh (darg)
            y4(i) = y1(i)
            y2(i) = dkap / snh
*  here for inhomogeneous propagators
            if (photof) then
              csh=cosh(darg)
              b=rnow+width*dhalf
              a=rnow-width*dhalf
              denom=dkap*snh
              fact=(-one+csh)*(q(i)-q(nch+i)*rnow)
              gam1(i)=(fact+(-b+a*csh+snh/dkap)*q(nch+i))/denom
              gam2(i)=(fact+(-a+b*csh-snh/dkap)*q(nch+i))/denom
            endif
          end if
        else
*  here if the relative slope in the wavevector matrix is greater than
*  1.**(-20) in magnitude, in which case a linear reference potential is used,
*  with airy functions as reference solutions
          droot = ( abs (dslope) ) ** doneth
          dalpha   = sign (droot, dslope)
          dbeta = - eignow(i) / dslope
          dx1 = dalpha * ( dbeta - width * dhalf)
          dx2 = dalpha * ( dbeta + width * dhalf)
          call airymp (dx1, dthet1, dphi1, dmmod1, dnmod1,scai1, scbi1,
     :             dzeta1)
          call airymp (dx2, dthet2, dphi2, dmmod2, dnmod2,scai2, scbi2,
     :             dzeta2)
          if (photof) then
* determine required airy integrals
            call intairy(dx1, xairy1, xbiry1)
            call intairy(dx2, xairy2, xbiry2)
* convert ground state wavefunction and its derivative from r as
* independent variable to x
            q(i)=q(i)-dbeta*q(nch+i)
            q(nch+i)=q(nch+i)
          endif

          x1 = dx1
          x2 = dx2
*-----------------------------------------------------------------------------
          if (x1 .gt. zero .and. x2 .gt. zero) then
*  here for both x  and x  positive
*                 1      2
            tnhfac = tanh(dzeta2 - dzeta1)
            bfact = sinh(dthet1 - dthet2) +
     :              tnhfac * sinh(dthet1 + dthet2)
            dlzeta = dzeta2 - dzeta1
            y2(i) = zero
            if (abs(dlzeta) .le. oflow) then
              b = dmmod1 * dmmod2 * cosh(dzeta2 - dzeta1) * bfact
              y2(i) = 1. / b
            end if
            y1(i) = dnmod1 * (sinh(dthet2 - dphi1)
     :            - tnhfac * sinh(dthet2 + dphi1) ) / (dmmod1 * bfact)
            y4(i) = dnmod2 * (sinh(dthet1 - dphi2)
     :            + tnhfac * sinh(dthet1 + dphi2) ) / (dmmod2 * bfact)
            if (photof) then
              gam1(i)=-scbi2*xairy2-scai2*xbiry2
     :           +exp(dlzeta)*scbi2*xairy1+exp(-dlzeta)*scai2*xbiry1
              gam2(i)=-scbi1*xairy1-scai1*xbiry1
     :           +exp(dlzeta)*scai1*xbiry2+exp(-dlzeta)*scbi1*xairy2
            endif
*-----------------------------------------------------------------------------
          else if (x1 .le. zero .and. x2 .le. zero) then
*  here for both x  and x  negative
*                 1      2
            b =  dmmod1 * dmmod2 * sin(dthet2 - dthet1)
            y2(i) = 1. / b
            y1(i) = dnmod1 * sin(dphi1 - dthet2)
     :            / (dmmod1 * sin(dthet2 - dthet1) )
            y4(i) = dnmod2 * sin(dphi2 - dthet1)
     :            / (dmmod2 * sin(dthet2 - dthet1) )
            if (photof) then
              delzet=dzeta2-dzeta1
              cs=cos(delzet)
              sn=sin(delzet)
              gam1(i)=-scai2*xairy2+scbi2*xbiry2
     :               +cs*(scai2*xairy1-scbi2*xbiry1)
     :               +sn*(scai2*xbiry1+scbi2*xairy1)
              gam2(i)=-scai1*xairy1+scbi1*xbiry1
     :               +cs*(scai1*xairy2-scbi1*xbiry2)
     :               -sn*(scai1*xbiry2+scbi1*xairy2)
            endif
*-----------------------------------------------------------------------------
          else if (x1 .gt. zero .and. x2 .le. zero) then
*  here for x  positive and x  negative
*            1               2
            dtnhfp = 1 + tanh(dzeta1)
            dtnhfm = 1 - tanh(dzeta1)
            bfact = cosh(dthet1) * ( - cos(dthet2) * dtnhfp
     :            + tanh(dthet1) * sin(dthet2) * dtnhfm)
            y2(i) = zero
            if (abs(dzeta1) .le. oflow) then
              y2(i) = cosh(dzeta1) * (dmmod1 * dmmod2 * bfact)
              y2(i) = one / y2(i)
            end if
            y1(i) = (dnmod1 * cosh(dphi1) * ( cos(dthet2) * dtnhfp
     :            - tanh(dphi1) * sin(dthet2) * dtnhfm) )
     :            / (dmmod1 * bfact)
            y4(i) = (dnmod2 * cosh(dthet1) * ( - cos(dphi2) * dtnhfp
     :            + tanh(dthet1) * sin(dphi2) * dtnhfm) )
     :            / (dmmod2 * bfact)
            if (photof) then
              cs2=cos(dzeta2)
              sn2=sin(dzeta2)
              ez1=exp(dzeta1)
              emz1=one/ez1
              gam1(i)=scbi2*(-cs2+xbiry2)
     :               +scai2*(sn2-xairy2)
     :                +emz1*xairy1*(scbi2*cs2-scai2*sn2)
     :                +ez1*xbiry1*(scai2*cs2+scbi2*sn2)
              gam2(i)=-scai1*xbiry1-scbi1*xairy1
     :                +emz1*scai1*(xairy2*cs2-xbiry2*sn2)
     :                +ez1*scbi1*(one-xbiry2*cs2-xairy2*sn2)
            endif
*-----------------------------------------------------------------------------
          else if (x2 .gt. zero .and. x1 .le. zero) then
*  here for x  positive and x  negative
*            2               1
            dtnhfp = 1 + tanh(dzeta2)
            dtnhfm = 1 - tanh(dzeta2)
            bfact = cosh(dthet2) * ( cos(dthet1) * dtnhfp
     :            - tanh(dthet2) * sin(dthet1) * dtnhfm)
            y2(i) = zero
            if (abs(dzeta2) .le. oflow) then
              y2(i) =  cosh(dzeta2) * (dmmod1 * dmmod2 * bfact)
              y2(i) = one / y2(i)
            end if
            y4(i) = (dnmod2 * cosh(dphi2) * ( cos(dthet1) * dtnhfp
     :            - tanh(dphi2) * sin(dthet1) * dtnhfm) )
     :            / (dmmod2 * bfact)
            y1(i) = (dnmod1 * cosh(dthet2) * ( - cos(dphi1) * dtnhfp
     :            + tanh(dthet2) * sin(dphi1) * dtnhfm) )
     :            / (dmmod1 * bfact)
            if (photof) then
              ez2=exp(dzeta2)
              emz2=one/ez2
              cs1=cos(dzeta1)
              sn1=sin(dzeta1)
              gam1(i)=-scai2*xbiry2-scbi2*xairy2
     :                +emz2*scai2*(xairy1*cs1-xbiry1*sn1)
     :                +ez2*scbi2*(one-xbiry1*cs1-xairy1*sn1)
* bug corrected here 4/14/94
              gam2(i)=scbi1*(-cs1+xbiry1)
     :               +scai1*(sn1-xairy1)
     :                +emz2*xairy2*(scbi1*cs1-scai1*sn1)
     :                +ez2*xbiry2*(scai1*cs1+scbi1*sn1)
* here is the old, incorrect code`
*             gam1(i)=scbi1*(-cs1+xbiry1)
*    :               +scai1*(sn1-xairy1)
*    :                +emz2*xairy2*(scbi1*cs1-scai1*sn1)
*    :                +ez2*xbiry2*(scai1*cs1+scbi1*sn1)
            endif
          end if
*-----------------------------------------------------------------------------
          y1(i) = dalpha * y1(i)
          y4(i) = dalpha * y4(i)
          y2(i) = dalpha * y2(i) / dpi
          if (photof) then
              dalph2=dalpha*dalpha
              gam1(i)=q(i)*gam1(i)*y2(i)*dpi
     :                +q(nch+i)*(y1(i)-y2(i))/dalpha
              gam2(i)=q(i)*gam2(i)*y2(i)*dpi
     :                +q(nch+i)*(y4(i)-y2(i))/dalpha
              gam1(i)=gam1(i)/dalph2
              gam2(i)=gam2(i)/dalph2
          endif
*  at this point the y1, y2, and y4 propagators correspond identically to
*  eqs. (38)-(44) of m. alexander and d. manolopoulos, "a stable linear
*  reference potential algorithm for solution ..."
        end if
10    continue
      return
      end
* -----------------------------------------------------------------------
      subroutine steppr (vecnow, vecnew, tmat, nmax, n)
*  determine matrix to transform log-deriv matrix into new interval
*  see eq. (22) of m.h. alexander, "hybrid quantum scattering algorithms ..."
* --------------------------------------------------------------------------
*  variables in call list:
*    vecnow:     on entry: matrix of eigenvectors of wavevector matrix in
*                current interval
*                on return: matrix of eigenvectors of wavevector matrix in
*                new interval - this is the matrix tn in eq. (22) of
*                m.h. alexander, "hybrid quantum scattering algorithms ..."
*    vecnew:     on entry:  contains matrix of eigenvectors in next interval
*    tmat:       on return: contains transformation matrix pn in eq. (22)
*    n:          number of channels
*    nmax:       maximum row dimension of matrices
*  subroutines called:
*     rgmmul:    generalized matrix multiply, called here to evaluate
*                a.b-transpose
* --------------------------------------------------------------------------
      implicit double precision (a-h,o-z)
*      real vecnow, vecnew, tmat
      integer n, nmax, isw
*  matrices of maximum row dimension nmax, stored in packed column form
      dimension vecnow(1), vecnew(1), tmat(1)
      data isw / 0/
cstart none
c;      call mxma (vecnew, 1, nmax, vecnow, nmax, 1, tmat, 1, nmax,
c;     :            n, n, n)
cend
cstart unix-darwin unix-x86
      call dgemm('n','t',n,n,n,1.d0,vecnew,nmax,vecnow,nmax,
     :           0d0,tmat,nmax)
cend
*  restore eigenvectors
      call matmov (vecnew, vecnow, n, n, nmax, nmax)
      return
      end
* -----------------------------------------------------------------------
      subroutine transp (a, n, nmax)
*  subroutine to carry out in place transposition of n x n matrix a
*  of maximum row dimension nmax stored in packed column form
*  uses blas routine dswap
*  written by:  millard alexander
*  current revision date: 23-sept-87
      implicit double precision (a-h,o-z)
      integer icol, icolpt, irowpt, n, nmax, nrow
      dimension a(1)
      icolpt = 2
      irowpt = nmax + 1
      do 100 icol = 1, n - 1
*  icolpt points to first sub-diagonal element in column icol
*  irowpt points to first super-diagonal element in row icol
*  nrow is number of subdiagonal elements in this column
        nrow = n - icol
        call dswap (nrow, a(icolpt), 1, a(irowpt), nmax)
        icolpt = icolpt + nmax + 1
        irowpt = irowpt + nmax + 1
  100 continue
      return
      end
* -----------------------------------------------------------------------
      function turn(e)
* current revision date: 23-sept-87
      implicit double precision (a-h,o-z)
      common/coconv/ econv,xmconv
      ee = e/econv
      r = 3.0d0
      dr = 0.5d0
10    r = r+dr
      call pot(vv0,r)
      if(vv0-ee) 20,50,30
20    if(dr.lt.0) goto 10
      goto 40
30    if(dr.gt.0) goto 10
40    dr = -dr*0.5d0
      if(abs(dr).gt.0.01d0) goto 10
50    turn = r
      return
      end
* -----------------------------------------------------------------------
      subroutine wavevc (w, eignow, scr1, scr2, rnow, nch, nmax)
*  this subroutine first sets up the wavevector matrix at rnow
*  then diagonalizes this matrix
*  written by:  millard alexander
*  current revision date: 14-dec-2007
* ----------------------------------------------------------------
*  variables in call list:
*  w:           matrix of maximum row dimension nmax used to store
*               wavevector matrix
*  eignow:      on return:  array containing eigenvalues of wavevector matrix
*  scr1, scr2:  scratch vectors of dimension at least nch
*  rnow:        value of interparticle separation at which wavevector matrix
*               is to be evaluated
*  nch:         number of channels
*  nmax:        maximum number of channels
*  subroutines called:
*     potmat:         determines wavevector matrix
*     tred1,tqlrat:   eispack routines to obtain eigenvalues of real,
*                     matrix
*     dsyevr:         latest lapack eigenvalue routine
*     dscal, dcopy:   linpack blas routines
* ----------------------------------------------------------------
      implicit double precision (a-h,o-z)
*      real rnow, xmin1
*      real eignow, scr1, scr2, w
      integer icol, ierr, ipt, nch, nmax, nmaxm1, nmaxp1, nrow
      external dscal, dcopy, potmat
*     external dscal, dcopy, potmat, tred1, tqlrat
*  square matrix (of row dimension nmax)
      dimension w(1)
*  vectors dimensioned at least nch
      dimension eignow(1), scr1(1), scr2(1)
*  local arrays (for lapack dsyevr)
cstart unix-darwin unix-x86
      dimension isuppz(2*nch),iwork(10*nch),work(57*nch)
cend

* ------------------------------------------------------------------
      data xmin1 / -1.d0/
      nmaxp1 = nmax + 1
      nmaxm1 = nmax - 1
      call potmat (w, rnow, nch, nmax)
*  since potmat returns negative of lower triangle of w(r) matrix (eq.(3) of
*  m.h. alexander, "hybrid quantum scattering algorithms ..."),
*  next loop changes its sign
      ipt = 1
      do 100 icol = 1, nch
*  nrow is the number of (diagonal plus subdiagonal) elements in column icol
*  ipt points to the diagonal element in column icol for a matrix stored in
*  packed column form
        nrow = nch - icol + 1
        call dscal (nrow, xmin1, w(ipt), 1)
        ipt = ipt + nmaxp1
 100  continue
*  next loop fills in upper triangle of w
      if (nch .gt. 1) then
        ipt = 2
        do 110 icol = 1, nch -1
*  ipt points to the first subdiagonal element in column icol
*  nrow is the number of subdiagonal elements in column icol
          nrow = nch - icol
          call dcopy (nrow, w(ipt), 1, w(ipt + nmaxm1), nmax)
          ipt = ipt + nmaxp1
110     continue
      end if
cstart unix-darwin unix-x86
      lwork=57*nch
      liwork=10*nch
      abstol=1.e-16
      lsup=2*nch
      call dsyevr('N','A','L',nch,w,nmax,vl,vu,il,iu,abstol,m,
     :   eignow,vecnow,nmax,isuppz,work,lwork,iwork,liwork,ierr)

      if (ierr .ne. 0) then
        write (6, 115) ierr
        write (9, 115) ierr
115     format (' *** IERR =',i3,' IN WAVEVC/DSYEVR;  ABORT ***')
        write (9, 120) (eignow (i), i=1, nch)
120     format (' EIGENVALUES ARE:',/,8(1pe16.8) )
        call exit
      end if
cend
cstart unix .and. .not. unix-darwin .and. .not. unix-x86
c;*  transform w to tridiagonal form
c;*  eignow, scr1 and scr2 are used as scratch vectors here
c;      call tred1 (nmax, nch, w, eignow, scr1, scr2)
c;*  get eigenvalues of tridiagonal matrix
c;      call tqlrat (nch, eignow, scr2, ierr)
c;      if (ierr .ne. 0) then
c;        write (9, 130) ierr
c;        write (6, 130) ierr
c;130     format
c;     :    (' *** TQLRAT IERR =', i3, ' .N.E. 0 IN WAVEVC; ABORT ***')
c;        call exit
c;      end if
cend
      return
      end
* -------------------------------------------------------------------------
      subroutine wavewr(jtot,jlpar,nu,nch,nchtop,rstart,rendld)
* -------------------------------------------------------
*  subroutine to write initial header information on wavefunction file
*  (file jobname.WFU, logical unit 22), unit is opened in subroutine openfi
*     written by:  millard alexander
*     latest revision:  11-dec-2011
*     common blocks amat and bmat are used to store real and
*     imaginary parts of asymptotic wavefunction (only used in
*     read of wavefunction from saved file)
*     increased nchtop to 1000
* -------------------------------------------------------
      implicit double precision (a-h,o-z)
      character*48 oldlab, oldpot
      character*20 cdate, olddat
      logical         airyfl, airypr, bastst, batch, chlist,
     :                csflag, flaghf, flagsu, ihomo, ipos, logdfl,
     :                logwr, noprin, partw, readpt, rsflag, swrit,
     :                t2test, t2writ, twomol, writs, wrpart, wrxsec,
     :                xsecwr, nucros, photof, wavefl
      include "common/parpot"
      common /colpar/ airyfl, airypr, bastst, batch, chlist,
     :                csflag, flaghf, flagsu, ihomo, ipos, logdfl,
     :                logwr, noprin, partw, readpt, rsflag, swrit,
     :                t2test, t2writ, twomol, writs, wrpart, wrxsec,
     :                xsecwr, nucros, photof, wavefl
      common /coered/ ered, rmu
      common /coeint/ eint(25)
      common /cojq/   jq(1)
      common /colq/   lq(1)
      common /coinq/  inq(1)
      common /coamat/ amat(25)
      common /cobmat/ bmat(25)
      common /cow/ w(25)
      common /cozmat/ zmat(25)
      common /cotq1/  dpsir(25)
      common /cotq2/  dpsii(25)
      common /coisc1/ isc1(25)
      common /cosc1/ sc1(10)
      common /cosc2/ sc2(10)
      common /cosc3/ sc3(10)
      common /cosc4/ sc4(10)
      common /cosc5/ sc5(10)
      common /cowave/ irec, ifil
      dimension iword(32), word(4)
      ifil=2
      zero=0.d0
      izero=0
      if (nchtop .gt. 1000) then
        write (6, 60) nchtop
60      format(/' *** NCHTOP=',i3,
     :    ' EXCEEDS MAX FOR STORAGE OF WAVEFUNCTION; ABORT ***')
        call exit
      endif
      call dater (cdate)
      j=1
      do  120 i=1,5
        read(cdate(j:j+3),'(A4)') iword(i)
        j=j+4
120   continue
      j=1
      do 125 i=1,10
        read(label(j:j+3),'(A4)') iword(i+5)
        j=j+4
125   continue
      j=1
      do 130 i=1,10
        read(potnam(j:j+3),'(A4)') iword(i+15)
        j=j+4
130   continue
      iword(26)=jtot
      iword(27)=jlpar
      iword(28)=nu
      iword(29)=nch
      iword(30)=0
      iword(31)=0
      iword(32)=0
      if (csflag) iword(30)=1
      if (flaghf) iword(31)=1
      if (photof) iword(32)=1
      word(1)=ered
      word(2)=rmu
      word(3)=rstart
      word(4)=rendld
      call dbwi(iword,32,ifil,1)
      call dbwi(jq,nch,ifil,0)
      call dbwi(lq,nch,ifil,0)
      call dbwi(inq,nch,ifil,0)
      call dbwr(word,4,ifil,0)
      call dbwr(eint,nch,ifil,0)
      call dbwc(ifil,1)
* debug
      call dbri(iword,32,ifil,1)
      call dbri(jq,nch,ifil,0)
      call dbri(lq,nch,ifil,0)
      call dbri(inq,nch,ifil,0)
      call dbrr(word,4,ifil,0)
      call dbrr(eint,nch,ifil,0)
* reserve one record for
* 1. number of open channels,
* 2. total number of records on wavefunction
* 3. asymptotic interparticle separation
* 4. wavevectors of open channels
* 5. bessel functions and derivatives for open channels
* 6. real and imaginary parts of S matrix
* 7. number of initial states for photodissociation
* 8. real and imaginary parts of photodissociation amplitude
      call dres(nchtop*5+4*nchtop**2+4,ifil,2)
* 1. channel packing list and
* 2. real and imaginary part of asymptotic scattering wavefunction
* 3. real and imaginary part of derivative of asymptotic scattering wavefuncti
      call dres(nchtop+4*nchtop**2,ifil,3)
      irec=3
      return
      entry waverd(jtot,jlpar,nu,nch,npts,nopen,nphoto,jflux,
     :            rstart,rendld,rinf)
      ifil=2
      izero=0
      call drest(ifil)
      call dbri(iword,32,ifil,1)
      j=1
      do  220 i=1,5
        write(olddat(j:j+3),'(A4)') iword(i)
        j=j+4
220   continue
      j=1
      do 225 i=1,10
        write(oldlab(j:j+3),'(A4)') iword(i+5)
        j=j+4
225   continue
      j=1
      do 230 i=1,10
        write(oldpot(j:j+3),'(A4)') iword(i+15)
        j=j+4
230   continue
      oldlab=oldlab(1:40)
      oldpot=oldpot(1:40)
      label=oldlab
      potnam=oldpot
      jtot=iword(26)
      jlpar=iword(27)
      nu=iword(28)
      nch=iword(29)
      if (iword(30) .eq. 1 .and. .not.csflag) then
        csflag=.true.
      endif
      if (iword(30) .eq. 0 .and. csflag) then
        csflag=.false.
      endif
      if (iword(31) .eq. 1) flaghf=.true.
      if (iword(32) .eq. 1) then
        photof=.true.
      else if (iword(32) .eq. 0) then
        photof=.false.
      endif
      write (6, 245) olddat
      if (jflux .ne. 0) write (3, 245) olddat
      if (jflux .eq. 0) write (2, 245) olddat
245   format('    FROM CALCULATION ON: ',(a))
      if (jflux .ne. 0) write (3, 250) oldlab
      if (jflux .eq. 0) write (2, 250) oldlab
      write (6, 250) oldlab
250   format('    INITIAL JOB LABEL: ', (a))
      if (jflux .ne. 0) write (3, 251) oldpot
      if (jflux .eq. 0) write (2, 251) oldpot
      write (6, 251) oldpot
251   format('    INITIAL POT NAME: ', (a))
      if (iword(31) .eq. 0) flaghf =.false.
* read in channel labels
      call dbri(jq,nch,ifil,0)
      call dbri(lq,nch,ifil,0)
      call dbri(inq,nch,ifil,0)
      call dbrr(word,4,ifil,0)
      ered=word(1)
      rmu=word(2)
      rstart=word(3)
      rendld=word(4)
      call dbrr(eint,nch,ifil,0)
* start reading in information from record 2 here
      call dbri(nrecs,1,ifil,2)
      npts=nrecs-3
      call dbri(nopen,1,ifil,izero)
      call dbri(nphoto,1,ifil,izero)
      call dbrr(rinf,1,ifil,izero)
* read in wavevectors, bessel functions j, j', n, n'
* first initialize to zero for all channels
      call dset(nch,zero,sc1,1)
      call dset(nch,zero,sc2,1)
      call dset(nch,zero,sc3,1)
      call dset(nch,zero,sc4,1)
      call dset(nch,zero,sc5,1)
      call dbrr(sc1,nopen,ifil,izero)
      call dbrr(sc2,nopen,ifil,izero)
      call dbrr(sc3,nopen,ifil,izero)
      call dbrr(sc4,nopen,ifil,izero)
      call dbrr(sc5,nopen,ifil,izero)
      nopsq=nopen*nopen
* read in sreal and simag, store in w and zmat
      call dbrr(w,nopsq,ifil, izero)
      call dbrr(zmat,nopsq,ifil, izero)
      if (photof) then
* read in number of initial photodissociation states
*        call dbri(mphoto,1,ifil,izero)
*        nphoto=mphoto
* read in real part of photodissociation amplitude
* overlay sreal which is not needed for photodissociation problem
          call dbrr(w,nphoto*nopen,ifil,izero)
* read in imaginary part of photodissociation amplitude
* overlay simag which is not needed for photodissociation problem
          call dbrr(zmat,nphoto*nopen,ifil,izero)
      endif
* read in channel packing list and real and imaginary parts
* of scattering wavefunction and derivative
      call dbri(isc1,nopen,ifil,3)
      call dbrr(amat,nopsq,ifil, izero)
      call dbrr(bmat,nopsq,ifil, izero)
      call dbrr(dpsir,nopsq,ifil, izero)
      call dbrr(dpsii,nopsq,ifil, izero)
      irec=3
      return
      end
* ----------------------------------------------------------------------
      subroutine psiasy(fj,fn,unit,sr,si,psir,psii,nopen,nmax)
* subroutine to determine real and imaginary part of asymptotic wavefunction o
* derivative of these
*  asmptotically, in the case of inelastic scattering, the wavefunction is
*  exp[-i(kr-l pi/2)] - S exp[i(kr-l pi/2)]
*  whereas in the case of photodissociation,
*  exp[-i(kr-l pi/2)] S - exp[i(kr-l pi/2)]
*  this is equivalent to, in the case of inelastic scattering
*  - yl (1-Sr) + jl Si + i [-jl(1+Sr)+yl Si]
*  and, for photodissociation,
*   yl (1-Sr) + jl Si + i [-jl(1+Sr)-yl Si]
*  written by:  millard alexander
*  current revision date:  16-jun-1990
* ---------------------------------------------------------------------
*  variables in call list:
*    fj             contains (for wavefunction calculation) the normalized
*                   ricatti bessel function jl
*                   contains (for derivative calculation) the derivative with
*                   respect to r of the normalized ricatti bessel function jl
*    fn             contains (for wavefunction calculation) the normalized
*                   ricatti bessel function yl
*                   contains (for derivative calculation) the derivative with
*                   respect to r of the normalized ricatti bessel function yl
*    unit           scratch vector
*    sr, si         matrices of order nmax x nmax which contain
*                   on input: real and imaginary parts of s-matrix
*                   on return: real and imaginary parts of asymptotic
*                   wavefunction
*    psir           on return contains nopen x nopen real part of
*                   asymptotic wavefunction (or derivative)
*    psii           on return contains nopen x nopen imag part of asymptotic
*                   wavefunction (or derivative)
*
*    nopen          number of open channels
*    nmax           row dimension of matrices
*  variables in common block /cophot/
*     photof        true if photodissociation calculation
*                   false if scattering calculation
*     wavefn        true if G(a,b) transformation matrices are saved
*                   to be used later in computing the wavefunction
* ----------------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      logical photof, wavefn
      common /cophot/ photof, wavefn
      dimension fj(1), fn(1), unit(1), sr(nmax,nmax), si(nmax,nmax),
     :          psii(nmax,nmax), psir(nmax,nmax)
      one=1.d0
      onemin=-1.d0
*   put unit vector into array unit
      do 80  icol = 1, nopen
        unit(icol) = one
80    continue
* first we want to calculate real part of wavefunction at infinity
* that is   yl(kr) (Sr-1) + jl(kr) Si for scattering or
*         - yl(kr) (Sr-1) + jl(kr) Si for photodissociation
* first move Sreal into psii
        call matmov (sr, psii, nopen, nopen, nmax, nmax)
* now subtract unit matrix
        call daxpy (nopen, onemin, unit, 1, psii(1, 1), nmax + 1)
* now premultiply by diagonal matrix -yl(kr) for photodissociation or
* +yl(kr) for scattering
        do 130 irow = 1, nopen
          fac=one*fn(irow)
          if (photof) fac=-fac
          call dscal(nopen, fac, psii(irow,1), nmax)
130     continue
* now store simag in psir
        call matmov(si, psir, nopen, nopen, nmax, nmax)
* premultiply by diagonal matrix jl(kr)
        do 140 irow = 1, nopen
          call dscal(nopen, fj(irow), psir(irow,1), nmax)
140     continue
* now evaluate +/- yl(kr) (Sr-1) + jl(kR) Si, save in psir
        do 150 icol = 1, nopen
          call daxpy(nopen, one, psii(1, icol), 1, psir(1,icol), 1)
150     continue
* psir now contains real part of asymptotic scattering wavefunction
* now compute imaginary part of asymptotic wavefunction
* that is - jl(kr) (1+Sr) + yl(kr) Si for scattering or
*         - jl(kr) (1+Sr) - yl(kr) Si for photodissociation
* now move Sreal into psii
        call matmov (sr, psii, nopen, nopen, nmax, nmax)
* now add unit matrix
        call daxpy (nopen, one, unit, 1, psii(1, 1), nmax + 1)
* now premultiply by diagonal matrix -jl(kr)
        do 157 irow = 1, nopen
          fac=-fj(irow)
          call dscal(nopen, fac, psii(irow,1), nmax)
157     continue
* replace real part of s matrix by real part of asymptotic wavefunction
        call matmov(psir,sr,nopen, nopen, nmax, nmax)
* premultiply Simag by diagonal matrix yl(kr) for scattering or by
* -yl(kr) for photodissociation
        do 159 irow = 1, nopen
          fac=fn(irow)
          if (photof) fac=-fac
          call dscal(nopen, fac, si(irow,1), nmax)
159     continue
* now evaluate - jl(kr) (1+Sr) +/- yl(kR) Si, save in psii
        do 161 icol = 1, nopen
          call daxpy(nopen, one, si(1, icol), 1, psii(1,icol), 1)
161     continue
* replace imaginary part of s matrix by imaginary part of
* asymptotic wavefunction
        call matmov(psii,si,nopen, nopen, nmax, nmax)
      return
      end
* ------------------------------------------------------------------
      subroutine psi(filnam,a)
*
* driver subroutine to calculate scattering wavefunction and fluxes
* from information stored in direct access file
*
* author: millard alexander
* current revision date: 15-apr-1997 by mha

* special version for 13p collisions
*
* ------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      character*(*) filnam
      character*40  psifil, wavfil, amplfil, flxfil
      character*20  cdate
      character*10  elaps, cpu
      character*5   s13p(12)
      logical exstfl, batch, lpar(3), photof, wavefn, adiab,
     :                ldum, csflag,kill,llpar(19),propf, sumf,
     :                coordf
      common /cowave/ irec, ifil
      common /colpar/ lpar, batch,ldum,csflag,llpar,photof
      common /cotrans/ ttrans(36)
      common /cojq/   jq(60)
      common /colq/   lq(10)
      common /coinq/  inq(60)
      common /coeint/ eint(100)
      common /cow/    sr(100)
      common /cozmat/ si(100)
      common /coamat/ psir(100)
      common /cobmat/ psii(100)
      common /coz/    scmat(100)
      common /cotq1/  dpsir(100)
      common /cotq2/  dpsii(100)
      common /cotq3/  scmat2(100)
      common /cosout/ nnout, jout(21)
      common /coiout/ niout, indout(10)
      common /coisc1/ ipack(10)
      common /coisc2/ nlist(50)
      common /coisc3/ nalist(60)
      common /coisc5/ nblist(60)
      common /cosc1/ pk(100)
      common /cosc2/ fj(10)
      common /cosc3/ fjp(10)
      common /cosc4/ fn(10)
      common /cosc5/ fnp(10)
      common /cosc6/ sc(100)
      common /cosc7/ sc1(100)
* common for y1, y2, y4
      common /cocent/ sc2(1)
      common /coered/ ered, rmu
      common /coconv/ econv, xmconv, ang2c
      common /codim/  nairy, mmax
*      common /cophot/ photof, wavefn
      common /coselb/ ibasty
      common /cosysi/ ispar(4), ipol
      common /coqvec/ mxphot, nphoto
      dimension a(7), sx(3)
      data s13p /'3SG0f','3SG1f','3PI0f','3PI1f','3PI2f','1PI1f',
     :           '3SG1e','3PI0e','3PI1e','3PI2e','1SG0e','1PI1e'/
*
      one=1.d0
      onemin=-1.d0
      zero=0.d0
* initialize timer
      call mtime(cpu0,ela0)
* input
      iflux=a(1)
      if (iflux .gt. 4 .or. iflux .lt. -3) then
        write (6, 2) iflux
2       format (' *** IFLUX =',i3,' MUST BE -3 ... 4  ***')
        return
      endif
      iprint=a(2)
      inchj = a(5)
      inchl = a(6)
      inchi = a(7)
      thresh=a(3)
      factr=a(4)
      coordf=.false.
      sumf=.false.
      adiab=.false.
      jflux=iabs(iflux)
      if (iflux .eq. -1 .or. iflux .eq. 2) adiab = .true.
      if (iflux .eq. -2) then
        sumf=.true.
        jflux=1
        adiab = .false.
      endif
      if (iflux .eq. 3) then
        jflux=1
        adiab=.false.
        coordf=.true.
        ny=a(2)
        ymin=a(3)
        dy=a(4)
        iprint=a(5)
        thresh=a(6)
        factr=a(7)
      endif
      if (jflux .eq. 4) then
        rout=a(2)
        adiab=.true.
        sumf=.false.
        coordf=.true.
      endif
      if (photof) then
         if (thresh .eq. 0.d0) thresh=-1.d9
         if (iprint .eq. 0) iprint= 1
      else
         if (factr .eq. 0.d0) factr=1.d0
      endif
      if (iprint .ne. 0) then
        kill=.false.
      else
        kill=.true.
      endif
*
* generate filename and check if it is present
      ien=0
      wavfil=filnam//'.wfu'
      call gennam(wavfil,filnam,ien,'wfu',lenfs)
      inquire(file = wavfil, exist = exstfl)
      if (.not. exstfl) then
          write(6,10) wavfil(1:lenfs)
10        format(' ** WAVEFUNCTION INFORMATION FILE ',(a),
     :           ' NOT FOUND **')
          return
      end if
* open file which holds transformation data and asymptotic wavefunction
      call dinit
      nfile = 22
      call dopen(2,nfile,wavfil)
      call dater(cdate)
* open file to save generated wavefunction
      if (jflux .eq. 0) then
        call gennam(psifil,filnam,ien,'psi',lenft)
        call openf(2,psifil,'sf',0)
* write a header
        call version(2)
        write(2,11)
        write(6,11)
11      format(/' ** WAVEFUNCTION DETERMINATION ***',/)
        write (2, 12) wavfil
12      format('    INFORMATION FROM FILE: ',(a))
        write (2,13) cdate
13    format('    THIS CALCULATION ON: ',(a))
      endif
      if (jflux .ne. 0) then
* open file to save generated flux
        call gennam(flxfil,filnam,ien,'flx',lenft)
        call openf(3,flxfil,'sf',0)
* write a header
        call version(3)
        if (jflux .eq. 1) then
          if (photof) then
            write(3,14)
            write(6,14)
14          format(/,
     :   ' ** DETERMINATION OF OUTGOING FLUX ***')
          else
            write(3,15)
            write(6,15)
15          format(/,
     :   ' ** DETERMINATION OF INCOMING AND OUTGOING FLUX ***')
          endif
        endif
        if (jflux .eq. 2) then
          write(3,16)
          write(6,16)
16        format(/' ** ADIABATIC ENERGIES ***',/)
        endif
        if (jflux .eq. 4) then
          write(3,17)
          write(6,17)
17        format(/' ** TRANSFORMATION MATRIX **',/)
        endif
        write (3,18) cdate
18      format('    THIS CALCULATION ON: ',(a))
      endif
* read header information, s matrix, and asymptotic wavefunction and
* derivative
      call waverd(jtot,jlpar,nu,nch,npts,nopen,nphoto,
     :            jflux,rstart,rendld,rinf)
      if (photof) then
        write (6, 19)
        if (jflux .eq. 0) write (2, 19)
        if (jflux .ne. 0) write (3, 19)
19      format('    PHOTODISSOCIATION BOUNDARY CONDITIONS')
      else
        write (6, 20)
        if (jflux .eq. 0) write (2, 20)
        if (jflux .ne. 0) write (3, 20)
20      format('    SCATTERING BOUNDARY CONDITIONS')
        photof=.false.
      endif
      if (adiab) then
        if (jflux .eq. 0)  write (2,21)
        if (jflux .ne. 0)  write (3,21)
        write (6,21)
21      format ('    ADIABATIC BASIS')
      endif
      if (.not.adiab .and. .not. sumf) then
        if (.not. coordf) then
          if (ibasty .ne. 7) then
            if (jflux .eq. 0) write (2,22)
            if (jflux .ne. 0)  write (3,22)
            write (6,22)
22          format ('    DIABATIC (ASYMPTOTIC) BASIS')
          else
            if (jflux .eq. 0) write (2,23)
            if (jflux .ne. 0)  write (3,23)
*  print flux even inside of closed region in molecular basis
            kill = .false.
            write (6,23)
23          format ('    MOLECULAR (CASE A) BASIS')
          endif
        else
          if (ny .gt. 0) then
            if (jflux .eq. 0) write (2,24)
            if (jflux .ne. 0) write (3,24)
            write (6,24)
24          format
     :       ('    COORDINATE SPACE FLUX; POSITIVE INDEX CHOSEN')
          else
            if (jflux .eq. 0) write (2,25)
            if (jflux .ne. 0) write (3,25)
            write (6,25)
25          format
     :       ('    COORDINATE SPACE FLUX; NEGATIVE INDEX CHOSEN')
          endif
        endif
      endif
      if (sumf) then
            if (jflux .eq. 0) write (2,26)
            if (jflux .ne. 0) write (3,26)
            write (6,26)
26          format
     :   ('    DIABATIC (ASYMPTOTIC) BASIS;',
     :    ' INELASTIC FLUX SUMMED OVER ROTATIONAL LEVELS')
      endif
      if (jflux .ne. 0) write (3, 12) wavfil
      write (6, 12) wavfil
      if (csflag) then
        if (jflux .ne. 0)
     :    write(3,27) ered*econv, rmu*xmconv, jtot, nu
        if (jflux .eq.0)
     :    write(2,27) ered*econv, rmu*xmconv, jtot, nu
        write(6,27) ered*econv, rmu*xmconv, jtot, nu
27      format('    ENERGY = ',f10.3,' cm(-1);  MASS = ',f9.4,
     :     ' amu',/,'    CS CALCULATION:  JTOT = ',i3,'; NU =',i3)
      else
        if (jflux .ne. 0)
     :     write(3,29) ered*econv, rmu*xmconv, jtot, jlpar
        if (jflux .eq. 0)
     :      write(2,29) ered*econv, rmu*xmconv, jtot, jlpar
        write(6,29) ered*econv, rmu*xmconv, jtot, jlpar
29      format('    ENERGY = ',f10.3,' cm(-1);  MASS = ',f9.4,
     :     /,'    CC CALCULATION:  JTOT = ',i3,'; JLPAR =',i3)
      endif
      if (iabs(jflux).eq.1) then
        if (rendld .ge. rinf) then
          write (6, 30) rendld, rinf
30        format (' *** FLUX DESIRED; BUT RENDLD=',f7.3,
     :            ' .GE. RINF=',f7.3)
          return
        endif
        write(3, 31) rendld, rinf
        write (6, 31) rendld, rinf
31      format ('    FLUXES DETERMINED FROM R = ',
     :        f7.3,' TO R = ',f7.3)
        if (coordf) then
          write (6,34) ymin, dy, ymin+(iabs(ny)-1)*dy
          write (3,34) ymin, dy, ymin+(iabs(ny)-1)*dy
34        format ('                           R-INT = ',f5.2,':',
     :          f5.2,':',f5.2)
        endif
        write(3,32) thresh
        write (6,32) thresh
32      format ('    CLOSED CHANNEL THRESHOLD = ',1pg10.3)
        write(3,33) factr
        write (6,33) factr
33      format ('    FACTOR FOR CLOSED CHANNEL DAMP = ',f5.2)
      else if(jflux.eq.2) then
        write(3, 35) rendld, rinf
        write (6, 35) rendld, rinf
35      format ('    ADIABATIC ENERGIES DETERMINED FROM R = ',
     :        f7.3,' TO R = ',f7.3)
      else if(jflux.eq.4) then
        write (6,36) rout
        write (3,36) rout
36      format (
     : '    DIABATIC->ADIABATIC TRANSFORMATION REQUESTED AT R = ',
     :     f7.3)
      else if(jflux.eq.0) then
        write(2, 37) rstart, rinf, npts
        write (6, 37) rstart, rinf, npts
37      format (
     :  /,'    WF DEFINED FROM R = ',f7.3,' TO R = ',f7.3,' AT ',
     :   i4,' POINTS',/)
      endif
      inch=0
* check if initial channel is in list of channels
* not for photodissociation
      if (.not. photof) then
        if (ibasty .ne. 7) then
          do 40 nn=1, nch
            j1 = jq(nn)
            l1 = lq(nn)
            i1 = inq(nn)
            if(j1.eq.inchj.and.l1.eq.inchl.and.i1.eq.inchi) then
              inch=nn
              goto 41
            endif
40        continue
        else
          inch=inchj
        endif
41      if ((jflux .ne. 2 .and. jflux .ne. 4).and. inch .eq. 0) then
          if (jflux.ne.0) write(3, 43) inchj, inchl, inchi
          write (6, 43) inchj, inchl, inchi
43        format( /,' ** CHANNEL (J, l, IN = ',2i3,i4,') NOT IN LIST')
          return
        endif
      endif
      do 45 i = 1, nch
45      nalist(i)=i
* reorder channels in increasing energy since this is eispack ordering
      if (nch .gt. 1) then
        call dcopy(nch,eint,1,sc1,1)
        do 50 i = 1,nch-1
          do 48 j = i+1,nch
            if (sc1(j).lt.sc1(i)) then
*  switch
              ehold=sc1(i)
              sc1(i)=sc1(j)
              sc1(j)=ehold
              inhold=nalist(i)
              nalist(i)=nalist(j)
              nalist(j)=inhold
            endif
48        continue
50      continue
      endif
      do 51 i = 1, nch
        if (inch .eq. nalist(i)) then
          incha=i
          goto 52
        endif
51    continue
52    continue
* nalist now contains ordering of channels in energy
*   nalist(i) is the number in original list of the channel of ith
*   lowest energy
      if (.not.coordf)  then
        if (jflux.ne.0) write(3, 55)
        write (6, 55)
55      format('    CHANNEL PARAMETERS:',
     :       '   N   J   L   IN    ENERGY(CM-1)    SQRT(K)')
        if (jflux .ne. 2) then
          inchc=inch
          if (adiab) inchc=incha
          if (.not.photof) then
            if (ibasty .ne. 7 .or.
     :          (ibasty .eq. 7 .and. (ipol .eq. 0 .or. adiab
     :           .and. jlpar .eq. 1))) then
              if (jflux.eq.0)
     :          write(2, 57) inchc, jq(inch), lq(inch), inq(inch),
     :            econv*eint(inch)
              if (jflux.ne.0)
     :          write(3, 57) inchc, jq(inch), lq(inch), inq(inch),
     :            econv*eint(inch)
              write (6, 57) inchc, jq(inch), lq(inch), inq(inch),
     :            econv*eint(inch)
57            format(/,15x,'INITIAL:',3i4,i5,f13.3)
            else if (ibasty .eq.7 .and. jlpar .eq. -1
     :              .and. ipol.ne.0) then
              if (jflux.eq.0)
     :          write(2, 58) inchc, s13p(inch+6),
     :            econv*eint(inch)
              if (jflux.ne.0)
     :          write(3, 58) inchc, s13p(inch+6),
     :            econv*eint(inch)
              write (6, 58) inchc, s13p(inch+6),
     :            econv*eint(inch)
58            format(/,15x,'INITIAL:  ',i2,3x,a5,f18.3)
            endif
          else
* initial channel always 1 for photodissociation, since only one
* column in wavefunction
            inch=1
            incha=1
            inchc=1
          endif
        endif
      endif
      if (jflux .eq. 4) then
        write (3,55)
        do 60  i=1, nch
          write (3, 59) i, jq(i), lq(i), inq(i), econv*eint(i)
59        format(10x,4i4,f13.3)
60      continue
      endif
      if (photof) then
        inch=1
        incha=1
        inchc=1
      endif
      nchsq=nch*nch
      nopsq=nopen*nopen
* make a list of pointers
* nlist is pointer to desired probed channels in full channel list
      nj = 0
      if (ibasty .ne. 7) then
        if (nnout .lt. 0) then
          write (6, 65) nnout
65        format ('  ** WARNING: NNOUT = ',i3,
     :          ' .LE. O IN SUBROUTINE PSI')
        else if (nnout .eq. 0) then
          if(jflux.ne. 4) then
            write (6, 68)
68          format ('  ** NO PROBE STATES REQUESTED?  ABORT ***')
            go to 700
          endif
        endif
      endif
      do 120 i=1, iabs(nnout)
         jo = jout(i)
         if (jflux .eq. 2) then
           if (ibasty .ne. 4) then
             llo = iabs(indout(i))/100
             io = sign(iabs(indout(i))-100*llo,indout(i))
           else
             llo = iabs(indout(i))/1000
             io = sign(iabs(indout(i))-1000*llo,indout(i))
           endif
         endif
         do 100 nn=1, nch
           j1 = jq(nn)
           if(j1.ne.jo) goto 100
             if (jflux .ne. 2) then
               do 75 in = 1, iabs(niout)
                 io = indout(in)
                 if(inq(nn).ne.io) goto 75
                 nj = nj + 1
                 nlist(nj) =nn
75             continue
             else
                innq=inq(nn)
                if(innq.ne.io .or. lq(nn) .ne. llo) goto 100
* check to see if state has already been found
                 ifound=0
                 do 80 if=1,nj
                   if (nn .eq. nlist(if)) ifound=1
80               continue
                 if (ifound .eq. 0) then
                   nj = nj + 1
                   nlist(nj) = nn
                 endif
             endif
100      continue
120   continue
* check if there had been any match
* if coordinate space flux or 13p scattering, include all states
      if (coordf .or. ibasty .eq. 7 .or. sumf) then
        nj=nch
        do 121 i=1, nch
          nlist(i)=i
121     continue
      endif
      if(nj.eq.0) then
        if(jflux.ne.4) then
          if (jflux .ne. 0) write(3,130)
          if (jflux .eq. 0) write(2,130)
          write(6,130)
          if(.not. batch) write(6,130)
130         format(' *** NO PROBE STATES FOUND, ABORT ***')
          goto 700
        endif
      end if
* reorder list in terms of energy
      if (adiab) then
        if (nj .gt. 1) then
          do 135 i=1, nj-1
            do 134 j=i+1,nj
              if (eint(nlist(j)) .lt. eint(nlist(i))) then
                nhold=nlist(i)
                nlist(i)=nlist(j)
                nlist(j)=nhold
              endif
134         continue
135       continue
        endif
      endif
* establish equivalence with adiabatic level list
      do 138 i = 1, nj
        do 136 j =1,nch
          if(nalist(j) .eq. nlist(i)) then
            nblist(i)=j
            goto 138
          endif
136     continue
138   continue
      if (.not. coordf) then
        if (.not.sumf) then
          do 142 i=1, nj
            nn=nlist(i)
            nnn=nn
            if (adiab) nnn=nblist(i)
            if (eint(nn) .le. ered) then
              sq=sqrt(2.d0*rmu*(ered-eint(nn)))
            else
              sq=-sqrt(2.d0*rmu*(-ered+eint(nn)))
            endif
            if (ibasty .ne. 7 .or. adiab) then
              if (jflux.eq.0)
     :        write(2, 140) nnn, jq(nn), lq(nn), inq(nn),
     :                 eint(nn)*econv, sq
              if (jflux.ne.0) write(3,140) nnn,jq(nn),lq(nn),inq(nn),
     :                 eint(nn)*econv, sq
              write (6, 140) nnn, jq(nn), lq(nn), inq(nn),
     :                 eint(nn)*econv, sq
140           format(16x,'PROBED:',3i4,i5,f13.3,f13.4)
            else
              if (jlpar .eq. -1) nn=nn+6
              if (jflux.eq.0)
     :        write(2, 141) nnn, s13p(nn),
     :                 eint(nnn)*econv, sq
              if (jflux.ne.0) write(3,141) nnn,s13p(nn),
     :                 eint(nnn)*econv, sq
              write (6, 141) nnn, s13p(nn),
     :                 eint(nnn)*econv, sq
141           format(16x,'PROBED:  ',i2,3x,a5,f18.3,f13.4)
            endif
142       continue
        else
          do 145 ni = 1, niout
            write (3, 143) indout(ni)
            write (6, 143) indout(ni)
143         format(16x,'PROBED:  INDEX =',i4)
145       continue
        endif
      endif
      if (jflux.eq.1) then
        if(.not.coordf) then
           write(3, 146)
           write (6, 146)
146        format(17x,'TOTAL:  LAST COLUMN')
        else
           write(3, 147)
           write (6, 147)
147        format('    TOTAL FLUX IN LAST COLUMN')
        endif
      endif
* reverse order of adiabatic states, since eispack routines return
* highest energy first
      do 148 i=1,nj
        nalist(i)=nch-nblist(i)+1
148   continue
      npoint=(inch-1)*nch + 1
* npoint points to top of column inch of full wavefunction matrix
      if (ibasty .eq.7 .and. jlpar.eq.-1 .and. ipol.eq.1) then
*         if (adiab) then
*           write (6, 149)
*           if (jflux.ne.0) write(3, 149)
*149        format('    STATE 5 IS PARALLEL POLARIZATION, STATE 6'm
*     :            ' IS PERPENDICULAR')
*         endif
         call waverot(jtot,nch)
       endif
* if 13p  or 2s-2p scattering, determine the matrix for case (a) -> case (e)
      if (ibasty .eq.7) call tcasea(jtot,jlpar)
      if (jflux .eq. 0) then
* here if wavefunction calculation
        if (.not.photof) then
*        if (photof) then
* here for scattering
* now expand psir, psii, dpsir, dpsii into nch x nch matrix, putting zeros
* as closed channel components
          if (nch .gt. nopen) then
            call expand(nopen,nopen,nch,nch,ipack,
     :                psir,psii,scmat,scmat2)
            call expand(nopen,nopen,nch,nch,ipack,
     :                dpsir,dpsii,scmat,scmat2)
          endif
* store desired wavefunction column (real and imaginary part) in 1st and 2nd
* columns of psir
          if (inch .ne. 1) call dcopy(nch,psir(npoint),1,psir,1)
          call dcopy(nch,psii(npoint),1,psir(nch+1),1)
          write(2, 150)
150       format(/' R (BOHR) AND REAL PART OF WAVEFUNCTION',
     :          ' (R < 0 INDICATES AIRY PROPAGATION)',/)
          call psicalc(npts,nch,nchsq,nj)
* copy imaginary part of asymptotic wavefunction into first column of psir
* so we can use same loop as above
          call dcopy(nch,psir(nch+1),1,psir,1)
          write(2, 185)
185       format(/' R (BOHR) AND IMAGINARY PART OF WAVEFUNCTION',
     :          '(R < 0 INDICATES AIRY PROPAGATION)',/)
          call psicalc(npts,nch,nchsq,nj)
        else
* here for photdissociation, in which case outgoing wavefunction is a
* given column of chi
* npoint points to which of the nphot ground state wavefunctions are to
* be selected
          if (nch .gt. nopen) then
            call expand(nopen,nopen,nch,nch,ipack,
     :                  psir,psii,scmat,scmat2)
            call expand(nopen,nopen,nch,nch,ipack,
     :                  dpsir,dpsii,scmat,scmat2)
          endif
* store desired wavefunction column (real and imaginary part) in 1st and
* 2nd columns of psir
          call dcopy(nch,psir(npoint),1,psir,1)
          call dcopy(nch,psii(npoint),1,psir(nch+1),1)
* store derivatives (real and imaginary)  in 3rd and 4th columns of psir
          call dcopy(nch,dpsir(npoint),1,psir(2*nch+1),1)
          call dcopy(nch,dpsii(npoint),1,psir(3*nch+1),1)
          ipoint=2*nch+1
          irec=npts+4
          write(2, 200)
200       format(/' R (BOHR) AND REAL PART OF CHI')
          iwf = 1
          propf=.true.
          call flux(npts,nch,nchsq,ipoint,nj,adiab,thresh,factr,kill,
     :            photof,propf,sumf,inch,iwf,coordf,ny,ymin,dy)
          write(2, 210)
210       format(/' R (BOHR) AND IMAGINARY PART OF CHI')
* reread asymptotic information
          call waverd(jtot,jlpar,nu,nch,npts,nopen,nphoto,
     :            jflux,rstart,rendld,rinf)
          if (nch .gt. nopen) then
            call expand(nopen,nopen,nch,nch,ipack,
     :                  psir,psii,scmat,scmat2)
            call expand(nopen,nopen,nch,nch,ipack,
     :                  dpsir,dpsii,scmat,scmat2)
          endif
* store desired wavefunction column (real and imaginary part) in 1st and
* 2nd columns of psir
          call dcopy(nch,psir(npoint),1,psir,1)
          call dcopy(nch,psii(npoint),1,psir(nch+1),1)
* store derivatives (real and imaginary)  in 3rd and 4th columns of psir
          call dcopy(nch,dpsir(npoint),1,psir(2*nch+1),1)
          call dcopy(nch,dpsii(npoint),1,psir(3*nch+1),1)
          iwf = -1
          irec=npts+4
          call flux(npts,nch,nchsq,ipoint,nj,adiab,thresh,factr,kill,
     :            photof,propf,sumf,inch,iwf,coordf,ny,ymin,dy)
        endif
      else if (jflux .eq. 2) then
        write(3, 300)
300     format(/' R (BOHR) AND ADIABATIC ENERGIES (CM-1)',/)
        irec=npts+4
        call eadiab(npts,nch,nchsq,nj)
      else if (jflux .eq. 4) then
        call transmt(npts,nch,nchsq,rout)
      else if (jflux .eq. 1) then
* here for flux calculation
* first for total flux (only for scattering)
* now expand psir, psii, dpsir, dpsii into nch x nch matrix, putting zeroz
* as closed channel components
        if (.not. photof) then
          if (nch .gt. nopen) then
            call expand(nopen,nopen,nch,nch,ipack,
     :           psir,psii,scmat,scmat2)
            call expand(nopen,nopen,nch,nch,ipack,
     :           dpsir,dpsii,scmat,scmat2)
          endif
* store desired wavefunction column (real and imaginary part) in 1st and 2nd
* columns of psir
          call dcopy(nch,psir(npoint),1,psir,1)
          call dcopy(nch,psii(npoint),1,psir(nch+1),1)
* store derivatives (real and imaginary)  in 3rd and 4th columns of psir
          call dcopy(nch,dpsir(npoint),1,psir(2*nch+1),1)
          call dcopy(nch,dpsii(npoint),1,psir(3*nch+1),1)
* now compute desired total fluxes
          write(3, 305)
305       format(/' R (BOHR) AND TOTAL FLUXES (UNITS OF HBAR/MU; ',
     :            'NO DAMPING)'/)
* first initial flux (not if adiabatic or not if 13p scattering or
* not summed fluxes)
          scsum=0.d0
          if (.not. adiab .and. ibasty .ne. 7 .and. .not.sumf) then
            do 310 i=1, nj
              nni=nlist(i)
              sc(i)=psir(nni)*psir(3*nch+nni)-psir(nch+nni)
     :              *psir(2*nch+nni)
            scsum=scsum+sc(i)
310         continue
            write(3, 320) rinf, (sc(i), i=1,nj), scsum
320         format(f10.4,30(1pe11.3))
          endif

          if ((.not. adiab .and. .not. coordf) .and. ibasty .ne.7) then
          scsum=0.d0
          if (.not.sumf) then
            do 321 i=1, nj
              nni=nlist(i)
              sc(i)=psir(nni)*psir(3*nch+nni)-psir(nch+nni)
     :            *psir(2*nch+nni)
              scsum=scsum+sc(i)
321         continue
            nout=nj
          else
* here for sum of fluxes over desired indices
            do 322 i=1,niout
              sc(i)=0.d0
322         continue
            scsum=0.d0
            do 330 i=1,nch
              nni=nalist(i)
              scc=psir(nni)*psir(3*nch+nni)-psir(nch+nni)
     :            *psir(2*nch+nni)
              do 327 ni=1, niout
                if (inq(nni) .eq. indout(ni)) sc(ni)=sc(ni)+scc
327           continue
330         continue
            scsum=dsum(niout,sc,1)
            nout=niout
          endif
          write(3, 320) rinf, (sc(i), i=1,nout), scsum
          endif
          irec=npts+4
          ipoint=2*nch+1
          iwf = 0
          propf=.true.
* plot out all fluxes for total flux which is numerically well behaved
          tthresh=-1.e9
          call flux(npts,nch,nchsq,ipoint,nj,adiab,thresh,factr,.false.,
     :            photof,propf,sumf,inch,iwf,coordf,ny,ymin,dy)
        endif
        if (.not. photof) then
* now for incoming flux (only for scattering)
* first construct real and imaginary parts of incoming waves
* here for scattering, in which case incoming flux is a diagonal matrix
          call dset(nchsq,zero,psir,1)
          call dset(nchsq,zero,psii,1)
          call dset(nchsq,zero,dpsir,1)
          call dset(nchsq,zero,dpsii,1)
          ipoint=1
          do 335 i=1, nch
            psir(ipoint)=-fn(i)
            psii(ipoint)=-fj(i)
            dpsir(ipoint)=-fnp(i)
            dpsii(ipoint)=-fjp(i)
            ipoint=ipoint+nch+1
335       continue
          write(3, 340)
340       format(/' R (BOHR) AND INCOMING FLUXES (UNITS OF HBAR/MU)',/)
          if (ibasty .eq.7 .and. jlpar.eq.-1 .and. ipol.eq.1)
     :        call waverot(jtot,nch)
* store desired wavefunction column (real and imaginary part) in 1st and 2nd
* columns of psir
          call dcopy(nch,psir(npoint),1,psir,1)
          call dcopy(nch,psii(npoint),1,psir(nch+1),1)
* store derivatives (real and imaginary)  in 3rd and 4th columns of psir
          call dcopy(nch,dpsir(npoint),1,psir(2*nch+1),1)
          call dcopy(nch,dpsii(npoint),1,psir(3*nch+1),1)
* now compute desired incoming fluxes
* first initial flux (not if adiabatic or not if 13p scattering or
* not summed fluxes)
          if (.not. adiab .and. ibasty .ne. 7 ) then
            if (.not.sumf) then
              scsum=0.d0
              do 360 i=1, nj
                nni=nlist(i)
                sc(i)=psir(nni)*psir(3*nch+nni)-psir(nch+nni)
     :              *psir(2*nch+nni)
              scsum=scsum+sc(i)
360           continue
              write(3, 320) rinf, (sc(i), i=1,nj), scsum
            else
* here for sum of fluxes over desired indices
              do 362 i=1,niout
                sc(i)=0.d0
362           continue
              scsum=0.d0
              do 365 i=1,nch
                nni=nalist(i)
                scc=psir(nni)*psir(3*nch+nni)-psir(nch+nni)
     :            *psir(2*nch+nni)
                do 364 ni=1, niout
                  if (inq(nni) .eq. indout(ni)) sc(ni)=sc(ni)+scc
364            continue
365           continue
              scsum=dsum(niout,sc,1)
              nout=niout
            endif
            write(3, 320) rinf, (sc(i), i=1,nout), scsum
          endif
          irec=npts+4
          ipoint=2*nch+1
          iwf = 0
          propf=.false.
          call flux(npts,nch,nchsq,ipoint,nj,adiab,thresh,factr,kill,
     :            photof,propf,sumf,inch,iwf,coordf,ny,ymin,dy)
        endif
* now for outgoing flux
        if (.not.photof) then
* outgoing wave: move Sreal into psir and Simag into psii
          call matmov (sr, psir, nopen, nopen, nopen, nopen)
          call matmov (si, psii, nopen, nopen, nopen, nopen)
* premultiply Sr by diagonal matrix yl(kr) and Si by jl(kr)
          do 430 irow = 1, nopen
            fac1=fn(irow)
            fac2=fj(irow)
            call dscal(nopen, fac1, psir(irow), nopen)
            call dscal(nopen, fac2, psii(irow), nopen)
430       continue
* add together, resave in psir, this is real part of outgoing wave
          call daxpy(nopsq, one, psii, 1, psir, 1)
* repeat for derivative of part of outgoing wave
          call matmov (sr, dpsir, nopen, nopen, nopen, nopen)
          call matmov (si, dpsii, nopen, nopen, nopen, nopen)
* premultiply Sr by diagonal matrix -ylp(kr) and Si by jlp(kr)
          do 440 irow = 1, nopen
            fac1=fnp(irow)
            fac2=fjp(irow)
            call dscal(nopen, fac1, dpsir(irow), nopen)
            call dscal(nopen, fac2, dpsii(irow), nopen)
440       continue
* add together, resave in dpsir, this is derivative of
* real part of outgoing wave
          call daxpy(nopsq, one, dpsii, 1, dpsir, 1)
* repeat for imaginary part of outgoing wave
          call matmov (si, psii, nopen, nopen, nopen, nopen)
          call matmov (sr, scmat, nopen, nopen, nopen, nopen)
* premultiply Sr by diagonal matrix -jl(kr) and Si by yl(kr)
          do 450 irow = 1, nopen
            fac1=fn(irow)
            fac2=-fj(irow)
            call dscal(nopen, fac1, psii(irow), nopen)
            call dscal(nopen, fac2, scmat(irow), nopen)
450       continue
* add together, resave in psii, this is imaginary part of outgoing wave
          call daxpy(nopsq, one,scmat, 1, psii, 1)
* repeat for derivative of imaginary part of outgoing wave
          call matmov (si, dpsii, nopen, nopen, nopen, nopen)
          call matmov (sr, scmat, nopen, nopen, nopen, nopen)
* premultiply Sr by diagonal matrix jl(kr) and Si by yl(kr)
          do 460 irow = 1, nopen
            fac1=fnp(irow)
            fac2=-fjp(irow)
            call dscal(nopen, fac1, dpsii(irow), nopen)
            call dscal(nopen, fac2, scmat(irow), nopen)
460       continue
* add together, resave in dpsii, this is imaginary part of derivative
* of outgoing wave
          call daxpy(nopsq, one,scmat, 1, dpsii, 1)
* now expand psir, psii, dpsir, dpsii into nch x nch matrix, putting zeroz
* as closed channel components
          if (nch .gt. nopen) then
            call expand(nopen,nopen,nch,nch,ipack,
     :                  psir,psii,scmat,scmat2)
            call expand(nopen,nopen,nch,nch,ipack,
     :                  dpsir,dpsii,scmat,scmat2)
          endif
          if (ibasty .eq.7 .and. jlpar.eq.-1 .and. ipol.eq.1
     :      .and. .not.photof)
     :       call waverot(jtot,nch)
        else
* here for photdissociation, in which case outgoing wavefunction is a
* given column of chi
* npoint points to which of the nphot ground state wavefunctions are to
* be selected
          if (nch .gt. nopen) then
            call expand(nopen,nopen,nch,nch,ipack,
     :                  psir,psii,scmat,scmat2)
            call expand(nopen,nopen,nch,nch,ipack,
     :                  dpsir,dpsii,scmat,scmat2)
          endif
        endif
* store desired wavefunction column (real and imaginary part) in 1st and 2nd
* columns of psir
        call dcopy(nch,psir(npoint),1,psir,1)
        call dcopy(nch,psii(npoint),1,psir(nch+1),1)
* store derivatives (real and imaginary)  in 3rd and 4th columns of psir
        call dcopy(nch,dpsir(npoint),1,psir(2*nch+1),1)
        call dcopy(nch,dpsii(npoint),1,psir(3*nch+1),1)


* now compute desired outgoing fluxes
        if (.not. photof) write(3, 550)
550     format(/' R (BOHR) AND OUTGOING FLUXES (UNITS OF HBAR/MU)',/)
        if (photof) write(3, 551)
551     format(/' R (BOHR) AND OUTGOING FLUXES (ATOMIC UNITS)',/)
* first initial flux
        if (coordf) then
          write (3, 554) (ymin+dy*(iy-1), iy=1,iabs(ny))
554       format('    R-INT:',f9.3,30(f11.3))
        endif
        if ((.not. adiab .and. .not. coordf) .and. ibasty .ne.7) then
          scsum=0.d0
          if (.not.sumf) then
            do 560 i=1, nj
             nni=nlist(i)
              sc(i)=psir(nni)*psir(3*nch+nni)-psir(nch+nni)
     :            *psir(2*nch+nni)
              scsum=scsum+sc(i)
560         continue
            nout=nj
          else
* here for sum of fluxes over desired indices
              do 575 i=1,niout
                sc(i)=0.d0
575           continue
              scsum=0.d0
              do 580 i=1,nch
                nni=nalist(i)
                scc=psir(nni)*psir(3*nch+nni)-psir(nch+nni)
     :            *psir(2*nch+nni)
                do 579 ni=1, niout
                  if (inq(nni) .eq. indout(ni)) sc(ni)=sc(ni)+scc
579            continue
580           continue
              scsum=dsum(niout,sc,1)
              nout=niout
          endif
          if (photof) then
            call dscal(nj,1.d0/rmu,sc,1)
            scsum=scsum/rmu
          endif
          write(3, 320) rinf, (sc(i), i=1,nout), scsum
        endif
        ipoint=2*nch+1
        irec=npts+4
        iwf = 0
        if (photof) propf=.true.
        if (.not. photof) propf=.false.
        call flux(npts,nch,nchsq,ipoint,nj,adiab,thresh,factr,kill,
     :            photof,propf,sumf,inch,iwf,coordf,ny,ymin,dy)
      endif
700   if (photof .or. jflux .eq. 0) close (2)
      if (jflux .ne. 0) close (3)
      call dclos(2)
      call mtime(cpu1,ela1)
      cpu1 = cpu 1 - cpu0
      ela1 = ela1 - ela0
      call gettim(cpu1,cpu)
      call gettim(ela1,elaps)
      if(.not. batch) then
        if (iflux .eq. 0) write(6,720) elaps, cpu
720     format(/,' ** WAVEFUNCTION CALCULATION FINISHED:',
     :       /,'    ELAPSED TIME:',(a),'  CPU TIME: ',(a))
        if (iflux .ne. 0) write(6,730) elaps, cpu
730     format(/,' ** FLUX CALCULATION FINISHED:',
     :       /,'    ELAPSED TIME:',(a),'  CPU TIME: ',(a))
      endif
      return
      end
* ------------------------------------------------------------------
      subroutine flux(npts,nch,nchsq,ipoint,nj,adiab,thresh,factr,kill,
     :                photof, propf, sumf,inch,iwf,coordf,nny,ymin,dy)
*
* subroutine to calculate fluxes
*
* author: millard alexander
* current revision date: 19-apr-1996 by mha
*
* ------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      logical adiab, kill, photof, propf, sumf, coordf, ifull
      common /cowave/ irec, ifil
      common /coamat/ psir(100)
      common /cobmat/ psii(100)
      common /cozmat/ tcoord(100)
* steve, you may need more space, but i doubt it since tcoord is dimensioned n
      common /coinq/  inq(60)
      common /coz/    scmat(100)
      common /cotq2/  scmat2(100)
      common /cotq3/  scmat3(100)
      common /coisc2/ nlist(60)
      common /coisc3/ nalist(60)
      common /cosc1/ pk(6)
      common /cosc6/ sc(60)
      common /cosc7/ sc1(6)
      common /cosc8/ sc8(6)
      common /cosc9/ sc9(6)
      common /cocent/ sc2(6)
      common /coered/ ered, rmu
      common /coground/ ifull
      common /cotrans/ ttrans(36)
      common /coselb/ ibasty
      common /coiout/ niout, indout(10)
      dimension scc(100)
      data zero, one, onemin /0.d0, 1.d0, -1.d0/
      data ione, mone /1,-1/
* if propf = true then true back-subsititution for flux
* if propf = false then inward propagation
* noffset is start of 5th column of psir
        noffset=4*nch+1
*        open (unit=23, file='propagators.txt',status='unknown')
* determine coordinate matrix if coordf true
        if (coordf) then
          ind=1
          ny=iabs(nny)
          do 50 i= 1, nch
            sc(i)=zero
            if(nny .gt. 0 .and. inq(i).gt. 0) sc(i)=one
            if(nny .lt. 0 .and. inq(i).lt. 0) sc(i)=one
50        continue
* sc is now mask for those states for which index is desired
          do 100 iy = 1, ny
            y=ymin+(iy-1)*dy
            ifull=.false.
            call wfintern(scmat,y,nch,1)
* steve, you'll need to modify wfintern so that scmat returns both function an
* scmat is a vector of length nch containing the nch internal states
* evaluated at internal coordinate y
            call vmul(sc,1,scmat,1,tcoord(ind),1,nch)
* this masks the internal states depending on whether the index is
* positive or negative
            ind=ind+nch
100       continue
        endif
* tcoord now contains as rows internal states and as columns
* values of internal coordinate

* here beings loop over sectors (R), starting from outermost sector
        do 420 kstep=1, npts
          irec=irec-1
          call dbrr(r,1,ifil,irec)
* branch out if we've gone beyond airy propagation region
          if (r .gt. 0) goto 450
          call dbrr(drnow,1,ifil,0)
* read in local wavevectors
          call dbrr(sc8,nch,ifil,0)
* read in first G(n,n+1) matrix,  then Tn transformation
* matrix into local interval
          call dbrr(scmat3,nchsq,ifil,0)
          call dbrr(scmat,nchsq,ifil,0)
* read in propagators (y1=pk, y2=sc1, y4=sc2, gam1=sc9,
*     muab= 5th column of psi)
          call dbrr(pk,nch,ifil,0)
          call dbrr(sc1,nch,ifil,0)
          call dbrr(sc2,nch,ifil,0)
          call dbrr(sc9,nch,ifil,0)
          call dbrr(psir(noffset),nch,ifil,0)
*          write (23, 299) -r, drnow, (scmat(ii), ii=1,4),
*     :      (pk(ii),ii=1,2),(sc1(ii),ii=1,2),
*     :      (sc2(ii),ii=1,2),(sc9(ii),ii=1,2),(psir(noffset+ii),ii=0,1)

299       format (2f16.12,14(1pe22.12e3))
* transform wave function into local basis
          if (propf) then
            call mxma(scmat,1,nch,psir,1,nch,scmat2,1,nch,nch,nch,2)
            call dcopy(2*nch,scmat2,1,psii(ipoint),1)
* here for back substitution for wavefunction
* 3rd and 4th columns of psii contain real and imaginary parts of function
* propagate functions
* evaluate G-tilde* psi-tilde(b)
             call mxma(scmat3,1,nch,psii(ipoint),1,nch,psii,1,
     :               nch,nch,nch,2)
* 1st two column of psii now contain G-tilde(A-B)*psi-tilde(b)
* if photodissociation, subtract off mu-tilde(a,b) from real part
            if (photof) call vadd(mone,psii,1
     :                          ,psir(noffset),1,nch)
* at this point 1st two columns of psii contain real and imaginary
*   psi-tilde(a)
* 3rd and 4th columns still contain psi-tilde(b)
* propagate derivatives
            call vmul(pk,1,psii,1,scmat2,1,nch)
            call vmul(pk,1,psii(1+nch),1,scmat2(1+nch),1,nch)
* first and second columns of scmat2 now contain y1 Fa
            call vmul(sc1,1,psii(ipoint),1,scmat2(ipoint),1,nch)
            call vmul(sc1,1,psii(ipoint+nch),1,
     :                scmat2(ipoint+nch),1,nch)
* 3rd and 4th columns of scmat2 now contain y2 Fb
            call daxpy(2*nch,onemin,scmat2,1,scmat2(ipoint),1)
* 3rd and 4th columns of scmat2 now contains (-y1 Fa + y2 Fb)
* this is psip-tilde(a)  move to 2nd and 3rd columns of psir
            call dcopy(2*nch,scmat2(ipoint),1,psir(ipoint),1)
* if photodissociation subtract off gamma1 from real part of derivative
            if (photof) call vadd(mone,psir(ipoint),1,sc9,1,nch)
* for compatibility with previous version, copy derivative into 3rd and
* 4th columns of psii
            call dcopy(2*nch,psir(ipoint),1,psii(ipoint),1)
          else
            do 300 ii=1, nch
              sc1(ii)=onemin/sc1(ii)
300         continue
            call mxma(scmat,1,nch,psir,1,nch,scmat2,1,nch,nch,nch,4)
            call dcopy(2*nch,scmat2,1,psii(ipoint),1)
            call dcopy(2*nch,scmat2(ipoint),1,psii,1)
* 1st two columns of psii now contain real and imaginary part of derivative
* 3rd and 4th columns contain real and imaginary parts of function
* propagate functions
            call vmul(sc2,1,psii(ipoint),1,scmat2,1,nch)
            call vmul(sc2,1,psii(ipoint+nch),1,scmat2(1+nch),1,nch)
* first and second columns of scmat2 now contain y4 Fb
            call daxpy(2*nch,onemin,scmat2,1,scmat2(ipoint),1)
* 3rd and 4th columns of scmat2 now contains (Fb' - y4 Fb)
* if photodissociation, subtract off gamma2 from real part
            if (photof) call vadd(mone,scmat2(2*nch+1),1
     :                          ,psir(noffset),1,nch)
* if photodissociation, 3rd column of scmat2 now contains
*     Re(Fb' - y4 Fb - gamma 2)
* multiply by - y2^-1 to get Fa
            call vmul(sc1,1,scmat2(ipoint),1,psii,1,nch)
            call vmul(sc1,1,scmat2(ipoint+nch),1,psii(1+nch),1,nch)
* 1st and 2nd columns of psii now contain Fa
            do 320 ii=1, nch
              sc1(ii)=onemin/sc1(ii)
320         continue
            call vmul(sc1,1,psii(ipoint),1,scmat2,1,nch)
            call vmul(sc1,1,psii(ipoint+nch),1,scmat2(1+nch),1,nch)
* 1st and 2nd columns of scmat2 now contain y2 Fb
* if photodissociation subtract off gamma1 from real part
            if (photof) call vadd(mone,scmat2,1,sc9,1,nch)
            call dscal(nch,onemin,pk,1)
            call vmul(pk,1,psii,1,psii(ipoint),1,nch)
            call vmul(pk,1,psii(1+nch),1,psii(ipoint+nch),1,nch)
* 3rd and 4th columns of psii now contain -y1 Fa
* add on y2 Fb and store in 3rd and 4th columns of psii
            call daxpy(2*nch,one,scmat2,1,psii(ipoint),1)
* if wavevector matrix positive (lambda negative) channel is closed
* kill the corresponding components of psi and psi'
* thresh is the threshold for killing closed channel components
          do 330 ii=1, nch
            if (sc8(ii) .lt. thresh) then
              fact=exp(-sqrt(abs(sc8(ii)))*drnow*factr)
              psii(ii)=fact*psii(ii)
              psii(ii+nch)=fact*psii(ii+nch)
              psii(ii+2*nch)=fact*psii(ii+2*nch)
              psii(ii+3*nch)=fact*psii(ii+3*nch)
            endif
330       continue
          endif
* 1st two columns of psii now contain Fa
* 3rd and 4th columns of psii now contain Fa'
          if (adiab) then
* here for flux calculation in locally adiabatic basis
            scsum=0.d0
            do 360 i=1, nj
              nni=nalist(i)
              sc(i)=psii(nni)*psii(3*nch+nni)-
     :              psii(nch+nni)*psii(2*nch+nni)
*  store real or imaginary parts of wf if desired
              if (iwf .eq. 1) pk(i)=psii(nni)
              if (iwf .eq. -1) pk(i)=psii(nch+nni)
* if wavevector matrix positive (lambda negative) channel is closed
* kill the corresponding components of psi and psi'
*              if (sc8(nni) .lt. thresh.and.kill) then
              if (sc8(nni) .lt. 0.d0.and.kill) then
                sc(i)=zero
                if (iwf .ne. 0) pk(i)=0.d0
              endif
              scsum=scsum+sc(i)
360         continue
            nout=nj
          endif
* transform wavefunction and derivative into asymptotic basis
          call mxma(scmat,nch,1,psii,1,nch,psir,1,nch,nch,nch,4)
* psir now contains this information
*          write (23, 299) -r, drnow, (psir(ii), ii=1,8)
          if (.not.adiab) then
* here for flux calculation in asymptotic basis
* calculate flux
            if (coordf) then
* here for coordinate space calculation of fluxes
              scsum=zero
* fluxes will be stored in vector sc, initialize to zero
              call dset(nch,zero,sc,1)
              do i=1,ny
                ind=(i-1)*nch+1
                scc1=ddot(nch,psir,1,tcoord(ind),1)
* scc1 contains sum(psi-real*phi_internal)
                scc2=ddot(nch,psir(nch+1),1,tcoord(ind),1)
* scc2 contains sum(psi-imag*phi_internal)
                scc3=ddot(nch,psir(2*nch+1),1,tcoord(ind),1)
* scc3 contains sum(dpsi-real*phi_internal)
                scc4=ddot(nch,psir(3*nch+1),1,tcoord(ind),1)
* scc4 contains sum(dpsi-imag*phi_internal)
                sc(i)=scc1*scc4-scc2*scc3
*steve, you'll need to append to this to calculate r-component of current dens
* try using sc9 as scratch storage for these
              enddo
              call dscal(ny,dy,sc,1)
* multiply by step width to recover J.R at ri times dri
              do i=1, ny
                scsum=scsum+sc(i)
              enddo
              nout=ny
            endif
            if (.not. coordf) then
* here for channel fluxes in diabatic basis
* transform wavefunction and derivative into molecular basis (only for
* 13p or 2s-2p
              if (sumf) call dset(niout,zero,scc,1)
              if (ibasty .eq. 7) then
                call mxma(ttrans,nch,1,psir,1,nch,
     :                    psii,1,nch,nch,nch,4)
* N. B.  as written, mxma multiplies psir by the transpose of ttrans
* psii now contains this transformed wavefunction and derivative
* copy these back to psir
                call dcopy(4*nch,psii,1,psir,1)
              endif
              do 370 i=1, nj
                mmi=nalist(i)
                nni=nlist(i)
                sc(i)=psir(nni)*psir(3*nch+nni)-
     :            psir(nch+nni)*psir(2*nch+nni)
*  store real or imaginary parts of wf if desired
                if (iwf .eq. 1) pk(i)=psii(nni)
                if (iwf .eq. -1) pk(i)=psii(nch+nni)
* if wavevector matrix positive (lambda negative) channel is closed
* kill the corresponding components of psi and psi'
                if (sc8(mmi) .lt. 0.d0.and.kill) then
*              if (sc8(mmi) .lt. thresh.and.kill) then
                  sc(i)=zero
                  if (iwf .ne. 0) pk(i)=0.d0
                endif
370           continue
              if (sumf) then
                do 390 i=1, nj
                  mmi=nalist(i)
                  do 375 ni=1, niout
                    if (inq(mmi) .eq. indout(ni)) then
                      scc(ni)=scc(ni)+sc(mmi)
                    endif
375               continue
390             continue
              endif
              if (.not.sumf) then
                nout=nj
                scsum=dsum(nj,sc,1)
              else
                nout=niout
                scsum=dsum(niout,scc,1)
              endif
* transform wavefunction and derivative back into asymptotic basis (only for
* 13p or 2s-2p
              if (ibasty .eq. 7) then
                call mxma(ttrans,1,nch,psir,1,nch,
     :                    psii,1,nch,nch,nch,4)
* psii now contains this transformed wavefunction and derivative
* copy these back to psir
                call dcopy(4*nch,psii,1,psir,1)
              endif
            endif
          endif
          if (iwf .ne. 0)
     :      write (2, 400) -r, (pk(i), i=1,nj)
          if (iwf .eq. 0) then
            if (photof) then
* for photodissociation, so, steve, you'll need to scale sc9 also
              call dscal(nout,1.d0/rmu,sc,1)
              scsum=scsum/rmu
              if (scsum .lt. 1.d-13) scsum=zero
            endif
            if (sumf) then
              write (3, 400) -r, (scc(i), i=1,nout), scsum
            else
              write (3, 400) -r, (sc(i), i=1,nout), scsum
* steve you'll also have to write out sc9
            endif
400         format(f10.4,30(1pe11.3))
          endif
420     continue

450     continue
*        close (23)
        return
        end
* ------------------------------------------------------------------
      subroutine eadiab(npts,nch,nchsq,nj)
*
* subroutine to readin and print out adiabatic energies
*
* author: millard alexander
* current revision date: 12-may-1997 by mha
*
* ------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      common /coered/ ered, rmu
      common /cowave/ irec, ifil
      common /coz/    scmat(100)
      common /coisc3/ nalist(10)
      common /cosc6/ sc(6)
      common /cosc8/ sc8(6)
      common /cosc7/ sc7(6)
* common for y1, y2, y4
      common /cocent/ sc2(6)
      data zero, one, onemin, two,   conv
     :    /0.d0, 1.d0, -1.d0, 2.d0, 219474.6d0/
        do 420 kstep=1, npts
          irec=irec-1
          call dbrr(r,1,ifil,irec)
* branch out if we've gone beyond airy propagation region
          if (r .gt. 0) return
          call dbrr(drnow,1,ifil,0)
* read in local wavevectors
          call dbrr(sc8,nch,ifil,0)
          do 370 i=1, nj
            nni=nalist(i)
            sc(i)=-conv*(sc8(nni)/(two*rmu)-ered)
370       continue
*          write (3, 170) -r+0.5*drnow, (nalist(i), i=1,nj),
          write (3, 170) -r+0.5*drnow,
     :        (sc(i), i=1,nj)
*170       format(f10.4,2i4,20(1pe12.4))
170       format(f10.4,20(1pe12.4))
420     continue
        return
        end
* ------------------------------------------------------------------
      subroutine waverot(jtot,nch)
* special for singlet-triplet mixing;
* rearrange wavefunction to correspond to state assignment:
* psi-parallel = (Jtot+1)^1/2 |el=J+1> - Jtot^1/2 |el=J-1>
* psi-perpendicular = Jtot^1/2 |el=J+1> + (Jtot+1)^1/2 |el=J-1>
* with assignment that original column five is singlet with el=J-1 and
* column 6 is singlet with el=J+1
* use orthogonal plane rotation
      implicit double precision (a-h,o-z)
      common /coamat/ psir(100)
      common /cobmat/ psii(100)
      common /cotq1/  dpsir(100)
      common /cotq2/  dpsii(100)
      xjtot=jtot
      cs=sqrt(xjtot+1.d0)
      sn=sqrt(xjtot)
      xnorm=sqrt(2.d0*xjtot+1.d0)
      cs=cs/xnorm
      sn=sn/xnorm
      jpoint=4*nch+1
      call drot(nch,psir(jpoint),1,psir(jpoint+nch),1,cs,sn)
      call drot(nch,psii(jpoint),1,psii(jpoint+nch),1,cs,sn)
      call drot(nch,dpsir(jpoint),1,dpsir(jpoint+nch),1,cs,sn)
      call drot(nch,dpsii(jpoint),1,dpsii(jpoint+nch),1,cs,sn)
      return
      end
* ------------------------------------------------------------------
      subroutine psicalc(npts,nch,nchsq,nj)
*
* subroutine to propagate wavefunctions inward
*
* author: millard alexander
* current revision date: 4-oct-1991 by mha
*
* ------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      common /cowave/ irec, ifil
      common /coamat/ psir(100)
      common /cow/    sr(100)
      common /cozmat/ si(100)
      common /cosc6/ sc(6)
      common /cosc7/ sc1(6)
      common /coisc2/ nlist(6)
        irec=npts+4
        do 180 kstep=1, npts
          irec=irec-1
          call dbrr(r,1,ifil,irec)
          call dbrr(drnow,1,ifil,0)
* read in adiabtic energies (which we don't need)
          call dbrr(sc1,nch,ifil,0)
* read in transformation matrices
          call dbrr(sr,nchsq,ifil,0)
          call mxma(sr,1,nch,psir,1,nch,si,1,nch,nch,nch,1)
          do 160 i=1, nj
            sc(i)=si(nlist(i))
160       continue
          call dcopy(nch,si,1,psir,1)
          write (2, 170) r, (sc(i), i=1,nj)
170       format(f10.4,12(1pe10.2))
180     continue
      return
      end
* ------------------------------------------------------------------
      subroutine transmt(npts,nch,nchsq,rout)
*
* subroutine to print out transformation matrix at rout
*
* author: millard alexander
* current revision date: 2-apr-2008 by q.ma (fixed typo in dbrr call)
*
* ------------------------------------------------------------------
      implicit double precision (a-h,o-z)
      logical renormf
      common /cowave/ irec, ifil
      common /coamat/ psir(100)
      common /cow/    sr(100)
      common /cozmat/ si(100)
      common /cosc6/ sc(6)
      common /cosc7/ sc1(6)
      common /coisc2/ nlist(6)
      dimension scrvec(64)
      irec=npts+4
      delold=1.d+18
      do 200 kstep=1, npts
          irec=irec-1
          call dbrr(r,1,ifil,irec)
          del=abs(abs(r)-rout)
          call dbrr(drnow,1,ifil,0)
* read in adiabtic energies (which we don't need)
          call dbrr(sc1,nch,ifil,0)
* read in first G(n,n+1) matrix,  then Tn transformation
* matrix into local interval
          call dbrr(sr,nchsq,ifil,0)
          call dbrr(si,nchsq,ifil,0)
          if (rout .gt. 0.d0) then
            if (del .gt.delold) then
* transpose matrix is stored column by column
* after transposition, columns correspond to eigenvectors
              call transp (si, nch, nch)
              write (3,160) -r+0.5*drnow
160      format('    TRANSFORMATION MATRIX AT R = ',f10.6,' IS:',/)
              write (6,161) abs(r)
161      format('    TRANSFORMATION MATRIX DETERMINED AT R = ',f10.6)
* print out transpose matrix (reverse order since eispack
* determines highest eigenvalue first
              ind=nchsq-nch+1
* if more than 64 channels, then eliminate all elements with i>64, and renormalize vector
              nnch=nch
              if (nch.gt.64) then
                 renormf=.true.
                 write (3,162) nch
                 write (6,162) nch
162      format('    CHANNEL EXPANSION TRUNCATED FROM NCH =',i4,
     :             ' TO NCH = 64;')
                 write (3,163)
                 write (6,163)
163      format('       EIGENVECTOR RENORMALIZED')
                 nnch=64
              else
                 renormf=.false.
              endif
              call openf(4,'tmatrix.dat','sf',0)
              nstate=min(12,nch)
              do 190 ii=1,nstate
*             do 190 ii=1,nch
                if (renormf) then
                   call dcopy(64,si(ind),1,scrvec,1)
                   cnorm=ddot(64,scrvec,1,scrvec,1)
                   cnorm=1d0/sqrt(cnorm)
                   call dscal(64,cnorm,scrvec,1)
                   call dcopy(64,scrvec,1,si(ind),1)
                endif
                write (3,175) -r+0.5*drnow, ii,
     :            (si(ij), ij=ind,ind+nnch-1)
                write (4,175) -r+0.5*drnow, ii,
     :            (si(ij), ij=ind,ind+nnch-1)
175           format(f7.4,i3,64f10.6)
                ind=ind-nch
190           continue
              close(4)
              return
            endif
          else
              call transp (si, nch, nch)
* print out transpose matrix (reverse order since eispack
* determines highest eigenvalue first
              ind=nchsq-nch+1

              call openf(4,'tmatrix.dat','sf',0)
              do 195 ii=1,nstate
                if (renormf) then
                   call dcopy(64,si(ind),1,scrvec,1)
                   cnorm=ddot(64,scrvec,1,scrvec,1)
                   cnorm=1d0/sqrt(cnorm)
                   call dscal(64,cnorm,scrvec,1)
                   call dcopy(64,scrvec,1,si(ind),1)
                endif
*              do 195 ii=1,nch
                write (4,175) -r+0.5*drnow, ii,
     :            (si(ij), ij=ind,ind+nnch-1)
                ind=ind-nch
195           continue
              close(4)
          endif
          call dcopy(nchsq,sr,1,si,1)
          delold=del
200   continue
* here if rout not reached at end of airy propagation region, print out
* last transformation matrix
      call transp (si, nch, nch)
      write (3,160)-r+0.5*drnow
      write (6,160)-r+0.5*drnow
* print out transpose matrix
      ind=nchsq-nch+1
      do 250 ii=1,12
*      do 250 ii=1,nch
        write (3,175) -r+0.5*drnow,  ii, (si(ij), ij=ind,ind+nch-1)
        ind=ind-nch
250   continue
      return
      end
