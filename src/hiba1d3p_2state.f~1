* --------------------------------------------------------------------
      subroutine ba1d3p (j, l, is, jhold, ehold, ishold, nlevel, nlevop,
     :                  rcut, jtot, flaghf, flagsu,
     :                  csflag, clist, bastst, ihomo, nu, numin, jlpar,
     :                  n, nmax, ntop)
* --------------------------------------------------------------------
*  subroutine to determine coupling potential (electrostatic + spin-orbit)
*  for collision involving the 1D and 3P states of atom in a p^4
*  electronic configuration with a structureless atom
*  author:  paul dagdigian
*  (based on the ba13p basis routine)
*
*  the spin-orbit part of the W matrix is computed as W(R) - W(R=inf)
*
*  THIS IS A TRUNCATED VERSION OF ba1d3p -- TWO-STATE MODEL FOR
*  O(1D) QUENCHING BY Xe:
*     The atoms are treated as j=0 species.  We consider only the
*     crossing of the 1Sigma+ and 3Pi states, coupled with a
*     an off-diagonal Gaussian coupling centered at the crossing R 
*     of the two curves.
*  This basis routine can be used with the oxe_1d3p_2state pot routine.
*  
*
*  current revision date:  15-may-2014 by p.dagdigian
* --------------------------------------------------------------------
*  variables in call list:
*    j:        on return contains electronic angular momentum quantum number
*              for each channel (j = 0, 1, 2 for the 3P spin-orbit levels
*              and j = 10 for the 1D2 level)
*    l:        on return contains orbital angular momentum for each
*              channel
*    is:       on return contains electronic spin of each channel (0 or 1)
*    jhold:    on return contains electronic angular momentum quantum number
*              for each level
*    ehold:    on return contains energy in hartrees of each level
*    ishold:   on return contains spin multiplicity of each level
*    nlevel:   on return contains number of energetically distinct
*              levels used in channel basis
*    nlevop:   on return contains number of energetically distinct
*              levels used in channel basis which are open
*              asymptotically
*    rcut:     cut-off point for keeping higher energy channels
*              if any open channel is still closed at r=rcut, then
*              all closed channels as well any open channels which are
*              still closed at r=rcut are dropped from basis
*              note that this is ignored in molecule-surface collisions!!!
*    jtot:     total angular momentum
*    flaghf:   if .true., then system with half-integer spin
*              if .false., then system with integer spin (this is the case
*              here)
*    flagsu:   if .true., then molecule-surface collisons
*    csflag:   if .true., then coupled-states calculation
*              if .false., the close-coupled calculation
*    clist:    if .true., then quantum numbers and energies listed for
*              each channel
*    bastst:   if .true., then execution terminates after the first call
*              to basis
*    ihomo:    if .true. , then homonuclear molecule
*              if .false., then heteronuclear molecule
*              if the molecule is homonuclear (ihomo = .true.), the
*              rotational levels included go from jmin to jmax in steps
*              of 2 and only even lambda terms in the anisotropy are
*              included
*    nu:       coupled-states projection index
*    numin:    minimum coupled states projection index
*              for cc calculations nu and numin are both set = 0 by calling
*              program
*    jlpar:    total parity of included channels in cc calculation
*              only those channels are included for which
*                  (-1)**(l-jtot)=jlpar
*              n.b. jlpar=+1 corresponds to f levels, jlpar=-1, to e levels
*    n:        on return equals number of channels
*    nmax:     maximum dimension of arrays
*    ntop:     maximum row dimension of all matrices passed to subroutines
*              propag and soutpt.  ntop is set in basis only if nu = numin
*              otherwise it is unchanged from the value supplied by the
*              calling program
*    note!!!   if flaghf = .true., then the true values of the rotational
*    quantum numbers, the total angular momentum, and the coupled-states
*    projection index are equal to the values stored in j, jtot, and nu
*    plus 1/2
*  variables in common block /cosysr/
*    isrcod:   number of real system dependent variables
*    en1d:     asymptotic energy of the 1D state (cm-1) relative to the center
*              gravity of the 3P sate
*  variables in common block /cosysi/
*    nscode:   total number of system dependent variables
*    isicod:   total number of integer system dependent variables
*    nterm:    number of different types of electronic coupling terms
*              this should be 1 here
*    nstate:   number of electronic states included
*              nstate=0:   just 1D state
*              nstate=1:   just 3P state
*              nstate=2:   both 1D and 3P states
*  variable in common block /cocent/
*    cent:      array containing centrifugal barrier of each channel
*  variable in common block /coeint/
*    eint:      array containing channel energies (in hartree)
*  variables in common block /coered/
*    ered:      collision energy in atomic units (hartrees)
*    rmu:       collision reduced mass in atomic units
*               (mass of electron = 1)
*  variable in common block /conlam/
*    nlam:      the number of case(a) interaction potentials actually used
*               this is :  nlam = nlam0 + nlam1
*               if only 1D channels, nlam = 3 (1Sigma+, 1Pi, 1Delta PE curves)
*               if only 3P channels, nlam = 6 (3Sigma- and 3Pi PE curves
*               and two spin-orbit matrix elements Axy and Axz, and the
*               R=inf values of Axy and Azy)
*               if both 1D and 3P channels, nlam= 19 (5 PE curves mentioned above,
*               2 spin-orbit 3P matrix elements, and 5 spin-orbit matrix
*               elements describing 1D-3P coupling, and the R-inf values of
*               7 spin-orbit matrix elements)
*    nlammx:    the maximum number of angular coupling terms
*  variable in common block /cov2/
*    nv2max:    maximum core memory allocated for the v2 matrix
*    v2:        lower triangle of nonzero angular coupling matrix elements
*               only nonzero elements are stored
*  variable in common block /coiv2/
*   iv2:        matrix address of v2 matrix for each non-zero element
*  variable in common block /coconv/
*     econv:    conversion factor from cm-1 to hartrees
*     xmconv:   converson factor from amu to atomic units
*  subroutines called:
*   vlm13p:    returns angular coupling coefficient for particular
*              choice of channel index
* ------------------------------------------------------------
      implicit double precision (a-h,o-z)
      logical ihomo, flaghf, csflag, clist, flagsu, bastst
      include "common/parbas"
      include "common/parbasl"

      common /cosysi/ nscode, isicod, nterm, nstate
      common /cosysr/ isrcod, junkr, en1d
      common /cov2/ nv2max, junkv, v2(1)
      common /coiv2/ iv2(1)
      common /conlam/ nlam, nlammx, lamnum(12)
      common /cocent/ cent(1)
      common /coeint/ eint(1)
      common /coered/ ered, rmu
      common /coskip/ nskip, iskip
      common /covvl/  vvl(3)
*   econv is conversion factor from cm-1 to hartrees
*   xmconv is converson factor from amu to atomic units
      common /coconv/ econv, xmconv
*   eigenvectors for the atomic Hamiltonian
      common /coeig/  c0(4,4), c1(3,3), c2(2,2)
      dimension j(1), l(1), jhold(1), ehold(1), 
     :          ishold(1), is(1), ieig(0:2)
*  scratch arrays for computing asymmetric top energies and wave fns.
      dimension en0(4), en1(3), en2(2), vec(4,4), work(288) 
      zero = 0.d0
      two = 2.d0
*  check for consistency in the values of flaghf and csflag
      if (flaghf) then
        write (6, 5)
        write (9, 5)
5       format (' *** FLAGHF = .TRUE. FOR 1D/3P ATOM; ABORT ***' )
        if (bastst) then
          return
        else
          call exit
        end if
      end if
      if (csflag) then
        write (6, 8)
        write (9, 8)
8      format
     :   ('  *** CSFLAG SET .FALSE. FOR 1D/3P ATOM CALCULATION ***')
        csflag=.false.
      end if
      if(nterm.ne.1) then
         write(6,9) nterm
         write(9,9) nterm
9        format(' *** NTERM = ',i3,' .NE. 1 FOR 1D/3P ATOM; ABORT')
         call exit
      end if
      nlam = 0
      nsum = 3
      if (nlam .ne. nsum) then
        if (bastst) write (6, 14) nsum
        write (9, 14) nsum
14      format (' ** TOTAL NUMBER OF ANISOTROPIC TERMS=', i2)
        nlam = nsum
      end if
      if (bastst) then
        if (flagsu) then
          write (6,16) rmu * xmconv, ered * econv, jtot, jlpar
          write (9,16) rmu * xmconv, ered * econv, jtot, jlpar
16        format(/' **  1D/3P ATOM ON UNCORRUGATED SURFACE ** RMU=',f9.4,
     :      ' E=', f7.2, /, '         JTOT=', i5, 2x,' JLPAR=',i2)
        else
          write (6,20) npot,
     :        rmu * xmconv, ered * econv, jtot, jlpar
          write (9,20) npot,
     :        rmu * xmconv, ered * econv, jtot, jlpar
20        format(/,' **  CC 1D/3P ATOM ; NPOT =',i2,' ** RMU=', f9.4,
     :        ' E=', f10.2, /, '         JTOT=', i5, 2x,' JLPAR=',i2)
        end if
        if (.not. flagsu) write (9,30) rcut
30      format (/' OPEN CHANNELS ELIMINATED WHICH ARE CLOSED AT R=',
     :          f6.2)
      endif
*
*  assign quantum numbers and energies
*  zero of energy is energy of lowest (3P2) level
      n=0
      nlevel = 0
      do istate = 1, 2
        li = jtot
        ix = (-1) ** (li - jtot)
        if (ix .eq. jlpar) then
*  here for correct orbital angular momentum
          n = n + 1
          if (n .gt. nmax) go to 130
          l(n) = li
          cent(n) = li * (li + 1.)
          if (istate .eq. 1) then
            is(n) = 3
          else
            is(n) = 1
          endif
          j(n) = 0
          eint(n) = 0.d0
          if (istate .eq. 2) then
            eint(n) = en1d / econv
          end if
        end if
        nlevel = nlevel + 1
        jhold(nlevel) = 0
        if (istate .eq. 1) then
          ishold(nlevel) = 3
        else
          ishold(nlevel) = 1
        endif
        ehold(nlevel) = 0.d0
        if (istate .eq. 2) then
          ehold(nlevel) = en1d / econv
        end if
      end do
*
130   if (n .gt. nmax) then
        write (9, 140) n, nmax
        write (6, 140) n, nmax
140     format(/' *** NCHANNELS=', i4,' .GT. MAX DIMENSION OF',
     :         i4,'; ABORT')
        if (bastst) then
          return
        else
          call exit
        end if
      end if
*  now check to see if any of the open channels are closed at r=rcut
*  this is not done for molecule-surface collisions or for rcut < 0
      if (.not.flagsu .and. rcut .gt. 0.d0 .and..not.boundc) then
        emin = 1.e+7
        do 145  i = 1, n
          if (eint(i) .le. ered) then
*  here if channel is
            if ( jtot * (jtot + 1) / (2. * rmu * rcut * rcut)
     :          .gt. (ered - eint(i)) ) then
*  here if channel is open asymptotically but closed at r = rcut
              if (eint(i) .lt. emin) emin = eint(i)
*  emin now contains the lowest channel energy for which this
*  condition is met
            end if
          end if
 145    continue
*  now eliminate all channels with eint .ge. emin if any of the channels
*  are open asymptotically but closed at r = rcut
        if (emin.lt.ered) then
          nn = 0
          do 150 i = 1, n
            if (eint(i) .lt. emin) then
*  here if this channel is to be included
              nn = nn + 1
              eint(nn) = eint(i)
              is(nn) = is(i)
              j(nn) = j(i)
              cent(nn) = cent(i)
              l(nn) = l(i)
            end if
150       continue
*  reset number of channels
          n = nn
        end if
      end if
*  return if no channels
      if (n .eq. 0) return
*  form list of energetically open levels and sort list
*  to put closed channels at end
      nlevop = 0
      if (nlevel .gt. 1) then
        do 180 i = 1, nlevel - 1
          if (ehold(i) .le. ered) then
            nlevop = nlevop + 1
          else
            do 175 ii = i + 1, nlevel
              if (ehold(ii) .le. ered) then
                nlevop = nlevop + 1
                ikeep = jhold(i)
                jhold(i) = jhold(ii)
                jhold(ii) = ikeep
                ikeep = ishold(i)
                ishold(i) = ishold(ii)
                ishold(ii) = ikeep
                ekeep = ehold(i)
                ehold(i) = ehold(ii)
                ehold(ii) = ekeep
                goto 180
              endif
175         continue
          endif
180     continue
      if (ehold(nlevel) .le. ered) nlevop = nlevop + 1
      else
*  here for only one level
        if (ehold(1) .le. ered) then
          nlevop = 1
        else
          nlevop = 0
        endif
      endif
      if (nlevop .le. 0) then
        write (9,185)
        write (6,185)
185     format('*** NO OPEN LEVELS IN BA1D3P; ABOST')	
        if (bastst) return
        call exit
      endif
*  ntop is the maximum row dimension of all matrices passed in the
*  call list of subroutines propag and soutpt.
      ntop = max(n, nlevop)
*  for fps make sure this is an odd number, for faster bank access.
*  this has no effect on vax or cray
        if (mod(ntop,2) .eq. 0 .and. ntop .lt. nmax)
     :       ntop = ntop + 1
*
*  now list channels if requested
      if (bastst) then
        write (6,1255)
        write (9,1255)
1255    format(/' ASYMPTOTIC ATOMIC ENERGY LEVELS'
     +    /'   N   S   J      EINT(CM-1)  ')
        do 1265 i = 1, nlevel
          write (6,2260) i, ishold(i), jhold(i), ehold(i) * econv
          write (9,2260) i, ishold(i), jhold(i), ehold(i) * econv
2260      format (3i4, f13.3)
1265    continue
        write (6, 255)
        write (9, 255)
255     format(/' CHANNEL BASIS FUNCTIONS'
     +      /'   N   S   J    L      EINT(CM-1)')
        do 265  i = 1, n
          write (6, 260) i, is(i), j(i), l(i), eint(i) * econv
          write (9, 260) i, is(i), j(i), l(i), eint(i) * econv
260       format (3i4, i5, f13.3)
265     continue
      end if
*
*  now calculate coupling matrix elements
      if (bastst) then
        write (6, 280)
        write (9, 280)
280     format (/' ILAM  LAMBDA  ICOL  IROW   I    IV2    VEE')
      end if
*
* i counts v2 elements
* inum counts v2 elements for given lambda
* ilam counts number of v2 matrices
* ij is address of given v2 element in present v2 matrix
      i = 0
      ilam=0
      do 320 il = 1, nlam
        lb = il
        ilam=ilam+1
        inum = 0
        ij=0
        do 310  icol= 1, n
          do 300  irow = icol, n
            ij = ntop * (icol - 1) + irow
            call vlm1d3p (j(irow), l(irow), is(irow), j(icol),
     :        l(icol), is(icol), jtot, lb, vee)
            if (vee .eq. 0) goto 300
              i = i + 1
              inum = inum + 1
              if (i .gt. nv2max) goto 300
                v2(i) = vee
                iv2(i) = ij
                if (bastst) then
                  write (6, 290) ilam, lb, icol, irow, i, iv2(i),
     :                           vee
                  write (9, 290) ilam, lb, icol, irow, i, iv2(i),
     :                           vee
290               format (i4, 2i7, 2i6, i6, g17.8)
                endif
300       continue
310     continue
410     if(ilam.gt.nlammx) then
        write(6,311) ilam
311     format(/' ILAM.GT.NLAMMX IN BA1D3P')
        call exit
      end if
      lamnum(ilam) = inum
      if (bastst) then
        write (6, 315) ilam, lamnum(ilam)
        write (9, 315) ilam, lamnum(ilam)
315     format ('ILAM=',i3,' LAMNUM(ILAM) = ',i6)
      end if
320   continue
*      nlam = ilam
      if ( i.gt. nv2max) then
        write (6, 350) i, nv2max
        write (9, 350) i, nv2max
350     format (' *** NUMBER OF NONZERO V2 ELEMENTS = ',i6,
     :           ' .GT. NV2MAX=',i6,'; ABORT ***')
        if (bastst) then
          return
        else
          call exit
        end if
      end if
      if (bastst) then
        write (6, 360) i
        write (9, 360) i
360     format (' ** TOTAL NUMBER OF NONZERO V2 MATRIX ELEMENTS IS',
     :           i6)
      end if
      return
      end
* --------------------------------------------------------------------
      subroutine vlm1d3p (j1, l1, i1, j2, l2, i2, jtot, lb, vee)
* --------------------------------------------------------------------
*  subroutine to evaluate the angular coupling matrix element for 
*  oxe 2-state model

*  author:  paul dagdigian
*  current revision date: 15-may-2014
* --------------------------------------------------------------------
*  variables in call list:
*  j1,l1,i1:    initial electronic orbital, orbital, and spin angular momenta
*  j2,l2,i1:    final electronic orbital, orbital, and spin angular momenta
*  jtot:     total angular momentum
*  lb:       value of expansion index:
*            lb=1:  singlet Sigma potential
*            lb=2:  triplet Pi potential
*            lb=3:  Gaussian coupling
*
      implicit double precision (a-h,o-z)
      vee = 0.d0
      if (lb .eq. 1) then
        if (i1 .eq. 1 .and. i2 .eq. 1) vee = 1.d0
      end if
      if (lb .eq. 2) then
        if (i1 .eq. 3 .and. i2 .eq. 3) vee = 1.d0
      end if
      if (lb .eq. 3) then
        if (i1. ne. i2) vee = 1.d0
      end if
      return
      end
* ------------------------------eof-----------------------------------
